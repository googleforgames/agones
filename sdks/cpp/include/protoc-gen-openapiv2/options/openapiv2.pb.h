// Copyright 2023 Google LLC All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This code was autogenerated. Do not edit directly.
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protoc-gen-openapiv2/options/openapiv2.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/struct.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto AGONES_EXPORT

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct AGONES_EXPORT TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto {
  static const ::uint32_t offsets[];
};
AGONES_EXPORT extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
namespace grpc {
namespace gateway {
namespace protoc_gen_openapiv2 {
namespace options {
class Contact;
struct ContactDefaultTypeInternal;
AGONES_EXPORT extern ContactDefaultTypeInternal _Contact_default_instance_;
class ExternalDocumentation;
struct ExternalDocumentationDefaultTypeInternal;
AGONES_EXPORT extern ExternalDocumentationDefaultTypeInternal _ExternalDocumentation_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
AGONES_EXPORT extern HeaderDefaultTypeInternal _Header_default_instance_;
class Info;
struct InfoDefaultTypeInternal;
AGONES_EXPORT extern InfoDefaultTypeInternal _Info_default_instance_;
class Info_ExtensionsEntry_DoNotUse;
struct Info_ExtensionsEntry_DoNotUseDefaultTypeInternal;
AGONES_EXPORT extern Info_ExtensionsEntry_DoNotUseDefaultTypeInternal _Info_ExtensionsEntry_DoNotUse_default_instance_;
class JSONSchema;
struct JSONSchemaDefaultTypeInternal;
AGONES_EXPORT extern JSONSchemaDefaultTypeInternal _JSONSchema_default_instance_;
class JSONSchema_ExtensionsEntry_DoNotUse;
struct JSONSchema_ExtensionsEntry_DoNotUseDefaultTypeInternal;
AGONES_EXPORT extern JSONSchema_ExtensionsEntry_DoNotUseDefaultTypeInternal _JSONSchema_ExtensionsEntry_DoNotUse_default_instance_;
class JSONSchema_FieldConfiguration;
struct JSONSchema_FieldConfigurationDefaultTypeInternal;
AGONES_EXPORT extern JSONSchema_FieldConfigurationDefaultTypeInternal _JSONSchema_FieldConfiguration_default_instance_;
class License;
struct LicenseDefaultTypeInternal;
AGONES_EXPORT extern LicenseDefaultTypeInternal _License_default_instance_;
class Operation;
struct OperationDefaultTypeInternal;
AGONES_EXPORT extern OperationDefaultTypeInternal _Operation_default_instance_;
class Operation_ExtensionsEntry_DoNotUse;
struct Operation_ExtensionsEntry_DoNotUseDefaultTypeInternal;
AGONES_EXPORT extern Operation_ExtensionsEntry_DoNotUseDefaultTypeInternal _Operation_ExtensionsEntry_DoNotUse_default_instance_;
class Operation_ResponsesEntry_DoNotUse;
struct Operation_ResponsesEntry_DoNotUseDefaultTypeInternal;
AGONES_EXPORT extern Operation_ResponsesEntry_DoNotUseDefaultTypeInternal _Operation_ResponsesEntry_DoNotUse_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
AGONES_EXPORT extern ResponseDefaultTypeInternal _Response_default_instance_;
class Response_ExamplesEntry_DoNotUse;
struct Response_ExamplesEntry_DoNotUseDefaultTypeInternal;
AGONES_EXPORT extern Response_ExamplesEntry_DoNotUseDefaultTypeInternal _Response_ExamplesEntry_DoNotUse_default_instance_;
class Response_ExtensionsEntry_DoNotUse;
struct Response_ExtensionsEntry_DoNotUseDefaultTypeInternal;
AGONES_EXPORT extern Response_ExtensionsEntry_DoNotUseDefaultTypeInternal _Response_ExtensionsEntry_DoNotUse_default_instance_;
class Response_HeadersEntry_DoNotUse;
struct Response_HeadersEntry_DoNotUseDefaultTypeInternal;
AGONES_EXPORT extern Response_HeadersEntry_DoNotUseDefaultTypeInternal _Response_HeadersEntry_DoNotUse_default_instance_;
class Schema;
struct SchemaDefaultTypeInternal;
AGONES_EXPORT extern SchemaDefaultTypeInternal _Schema_default_instance_;
class Scopes;
struct ScopesDefaultTypeInternal;
AGONES_EXPORT extern ScopesDefaultTypeInternal _Scopes_default_instance_;
class Scopes_ScopeEntry_DoNotUse;
struct Scopes_ScopeEntry_DoNotUseDefaultTypeInternal;
AGONES_EXPORT extern Scopes_ScopeEntry_DoNotUseDefaultTypeInternal _Scopes_ScopeEntry_DoNotUse_default_instance_;
class SecurityDefinitions;
struct SecurityDefinitionsDefaultTypeInternal;
AGONES_EXPORT extern SecurityDefinitionsDefaultTypeInternal _SecurityDefinitions_default_instance_;
class SecurityDefinitions_SecurityEntry_DoNotUse;
struct SecurityDefinitions_SecurityEntry_DoNotUseDefaultTypeInternal;
AGONES_EXPORT extern SecurityDefinitions_SecurityEntry_DoNotUseDefaultTypeInternal _SecurityDefinitions_SecurityEntry_DoNotUse_default_instance_;
class SecurityRequirement;
struct SecurityRequirementDefaultTypeInternal;
AGONES_EXPORT extern SecurityRequirementDefaultTypeInternal _SecurityRequirement_default_instance_;
class SecurityRequirement_SecurityRequirementEntry_DoNotUse;
struct SecurityRequirement_SecurityRequirementEntry_DoNotUseDefaultTypeInternal;
AGONES_EXPORT extern SecurityRequirement_SecurityRequirementEntry_DoNotUseDefaultTypeInternal _SecurityRequirement_SecurityRequirementEntry_DoNotUse_default_instance_;
class SecurityRequirement_SecurityRequirementValue;
struct SecurityRequirement_SecurityRequirementValueDefaultTypeInternal;
AGONES_EXPORT extern SecurityRequirement_SecurityRequirementValueDefaultTypeInternal _SecurityRequirement_SecurityRequirementValue_default_instance_;
class SecurityScheme;
struct SecuritySchemeDefaultTypeInternal;
AGONES_EXPORT extern SecuritySchemeDefaultTypeInternal _SecurityScheme_default_instance_;
class SecurityScheme_ExtensionsEntry_DoNotUse;
struct SecurityScheme_ExtensionsEntry_DoNotUseDefaultTypeInternal;
AGONES_EXPORT extern SecurityScheme_ExtensionsEntry_DoNotUseDefaultTypeInternal _SecurityScheme_ExtensionsEntry_DoNotUse_default_instance_;
class Swagger;
struct SwaggerDefaultTypeInternal;
AGONES_EXPORT extern SwaggerDefaultTypeInternal _Swagger_default_instance_;
class Swagger_ExtensionsEntry_DoNotUse;
struct Swagger_ExtensionsEntry_DoNotUseDefaultTypeInternal;
AGONES_EXPORT extern Swagger_ExtensionsEntry_DoNotUseDefaultTypeInternal _Swagger_ExtensionsEntry_DoNotUse_default_instance_;
class Swagger_ResponsesEntry_DoNotUse;
struct Swagger_ResponsesEntry_DoNotUseDefaultTypeInternal;
AGONES_EXPORT extern Swagger_ResponsesEntry_DoNotUseDefaultTypeInternal _Swagger_ResponsesEntry_DoNotUse_default_instance_;
class Tag;
struct TagDefaultTypeInternal;
AGONES_EXPORT extern TagDefaultTypeInternal _Tag_default_instance_;
}  // namespace options
}  // namespace protoc_gen_openapiv2
}  // namespace gateway
}  // namespace grpc
PROTOBUF_NAMESPACE_OPEN
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Contact* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Contact>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Header* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Header>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Info* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Info>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Info_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Info_ExtensionsEntry_DoNotUse>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_ExtensionsEntry_DoNotUse>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::License* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::License>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Operation* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Operation>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Operation_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Operation_ExtensionsEntry_DoNotUse>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Operation_ResponsesEntry_DoNotUse* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Operation_ResponsesEntry_DoNotUse>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Response* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Response>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Response_ExamplesEntry_DoNotUse* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Response_ExamplesEntry_DoNotUse>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Response_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Response_ExtensionsEntry_DoNotUse>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Response_HeadersEntry_DoNotUse* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Response_HeadersEntry_DoNotUse>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Schema* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Schema>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Scopes>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Scopes_ScopeEntry_DoNotUse* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Scopes_ScopeEntry_DoNotUse>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions_SecurityEntry_DoNotUse* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions_SecurityEntry_DoNotUse>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement_SecurityRequirementEntry_DoNotUse* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement_SecurityRequirementEntry_DoNotUse>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement_SecurityRequirementValue* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement_SecurityRequirementValue>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_ExtensionsEntry_DoNotUse>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Swagger* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Swagger>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Swagger_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Swagger_ExtensionsEntry_DoNotUse>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Swagger_ResponsesEntry_DoNotUse* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Swagger_ResponsesEntry_DoNotUse>(Arena*);
template <>
AGONES_EXPORT ::grpc::gateway::protoc_gen_openapiv2::options::Tag* Arena::CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Tag>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace grpc {
namespace gateway {
namespace protoc_gen_openapiv2 {
namespace options {
enum JSONSchema_JSONSchemaSimpleTypes : int {
  JSONSchema_JSONSchemaSimpleTypes_UNKNOWN = 0,
  JSONSchema_JSONSchemaSimpleTypes_ARRAY = 1,
  JSONSchema_JSONSchemaSimpleTypes_BOOLEAN = 2,
  JSONSchema_JSONSchemaSimpleTypes_INTEGER = 3,
  JSONSchema_JSONSchemaSimpleTypes_NULL_ = 4,
  JSONSchema_JSONSchemaSimpleTypes_NUMBER = 5,
  JSONSchema_JSONSchemaSimpleTypes_OBJECT = 6,
  JSONSchema_JSONSchemaSimpleTypes_STRING = 7,
  JSONSchema_JSONSchemaSimpleTypes_JSONSchema_JSONSchemaSimpleTypes_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  JSONSchema_JSONSchemaSimpleTypes_JSONSchema_JSONSchemaSimpleTypes_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

AGONES_EXPORT bool JSONSchema_JSONSchemaSimpleTypes_IsValid(int value);
constexpr JSONSchema_JSONSchemaSimpleTypes JSONSchema_JSONSchemaSimpleTypes_JSONSchemaSimpleTypes_MIN = static_cast<JSONSchema_JSONSchemaSimpleTypes>(0);
constexpr JSONSchema_JSONSchemaSimpleTypes JSONSchema_JSONSchemaSimpleTypes_JSONSchemaSimpleTypes_MAX = static_cast<JSONSchema_JSONSchemaSimpleTypes>(7);
constexpr int JSONSchema_JSONSchemaSimpleTypes_JSONSchemaSimpleTypes_ARRAYSIZE = 7 + 1;
AGONES_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
JSONSchema_JSONSchemaSimpleTypes_descriptor();
template <typename T>
const std::string& JSONSchema_JSONSchemaSimpleTypes_Name(T value) {
  static_assert(std::is_same<T, JSONSchema_JSONSchemaSimpleTypes>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to JSONSchemaSimpleTypes_Name().");
  return JSONSchema_JSONSchemaSimpleTypes_Name(static_cast<JSONSchema_JSONSchemaSimpleTypes>(value));
}
template <>
inline const std::string& JSONSchema_JSONSchemaSimpleTypes_Name(JSONSchema_JSONSchemaSimpleTypes value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<JSONSchema_JSONSchemaSimpleTypes_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool JSONSchema_JSONSchemaSimpleTypes_Parse(absl::string_view name, JSONSchema_JSONSchemaSimpleTypes* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JSONSchema_JSONSchemaSimpleTypes>(
      JSONSchema_JSONSchemaSimpleTypes_descriptor(), name, value);
}
enum SecurityScheme_Type : int {
  SecurityScheme_Type_TYPE_INVALID = 0,
  SecurityScheme_Type_TYPE_BASIC = 1,
  SecurityScheme_Type_TYPE_API_KEY = 2,
  SecurityScheme_Type_TYPE_OAUTH2 = 3,
  SecurityScheme_Type_SecurityScheme_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SecurityScheme_Type_SecurityScheme_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

AGONES_EXPORT bool SecurityScheme_Type_IsValid(int value);
constexpr SecurityScheme_Type SecurityScheme_Type_Type_MIN = static_cast<SecurityScheme_Type>(0);
constexpr SecurityScheme_Type SecurityScheme_Type_Type_MAX = static_cast<SecurityScheme_Type>(3);
constexpr int SecurityScheme_Type_Type_ARRAYSIZE = 3 + 1;
AGONES_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
SecurityScheme_Type_descriptor();
template <typename T>
const std::string& SecurityScheme_Type_Name(T value) {
  static_assert(std::is_same<T, SecurityScheme_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return SecurityScheme_Type_Name(static_cast<SecurityScheme_Type>(value));
}
template <>
inline const std::string& SecurityScheme_Type_Name(SecurityScheme_Type value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<SecurityScheme_Type_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SecurityScheme_Type_Parse(absl::string_view name, SecurityScheme_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SecurityScheme_Type>(
      SecurityScheme_Type_descriptor(), name, value);
}
enum SecurityScheme_In : int {
  SecurityScheme_In_IN_INVALID = 0,
  SecurityScheme_In_IN_QUERY = 1,
  SecurityScheme_In_IN_HEADER = 2,
  SecurityScheme_In_SecurityScheme_In_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SecurityScheme_In_SecurityScheme_In_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

AGONES_EXPORT bool SecurityScheme_In_IsValid(int value);
constexpr SecurityScheme_In SecurityScheme_In_In_MIN = static_cast<SecurityScheme_In>(0);
constexpr SecurityScheme_In SecurityScheme_In_In_MAX = static_cast<SecurityScheme_In>(2);
constexpr int SecurityScheme_In_In_ARRAYSIZE = 2 + 1;
AGONES_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
SecurityScheme_In_descriptor();
template <typename T>
const std::string& SecurityScheme_In_Name(T value) {
  static_assert(std::is_same<T, SecurityScheme_In>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to In_Name().");
  return SecurityScheme_In_Name(static_cast<SecurityScheme_In>(value));
}
template <>
inline const std::string& SecurityScheme_In_Name(SecurityScheme_In value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<SecurityScheme_In_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SecurityScheme_In_Parse(absl::string_view name, SecurityScheme_In* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SecurityScheme_In>(
      SecurityScheme_In_descriptor(), name, value);
}
enum SecurityScheme_Flow : int {
  SecurityScheme_Flow_FLOW_INVALID = 0,
  SecurityScheme_Flow_FLOW_IMPLICIT = 1,
  SecurityScheme_Flow_FLOW_PASSWORD = 2,
  SecurityScheme_Flow_FLOW_APPLICATION = 3,
  SecurityScheme_Flow_FLOW_ACCESS_CODE = 4,
  SecurityScheme_Flow_SecurityScheme_Flow_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SecurityScheme_Flow_SecurityScheme_Flow_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

AGONES_EXPORT bool SecurityScheme_Flow_IsValid(int value);
constexpr SecurityScheme_Flow SecurityScheme_Flow_Flow_MIN = static_cast<SecurityScheme_Flow>(0);
constexpr SecurityScheme_Flow SecurityScheme_Flow_Flow_MAX = static_cast<SecurityScheme_Flow>(4);
constexpr int SecurityScheme_Flow_Flow_ARRAYSIZE = 4 + 1;
AGONES_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
SecurityScheme_Flow_descriptor();
template <typename T>
const std::string& SecurityScheme_Flow_Name(T value) {
  static_assert(std::is_same<T, SecurityScheme_Flow>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Flow_Name().");
  return SecurityScheme_Flow_Name(static_cast<SecurityScheme_Flow>(value));
}
template <>
inline const std::string& SecurityScheme_Flow_Name(SecurityScheme_Flow value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<SecurityScheme_Flow_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool SecurityScheme_Flow_Parse(absl::string_view name, SecurityScheme_Flow* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SecurityScheme_Flow>(
      SecurityScheme_Flow_descriptor(), name, value);
}
enum Scheme : int {
  UNKNOWN = 0,
  HTTP = 1,
  HTTPS = 2,
  WS = 3,
  WSS = 4,
  Scheme_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Scheme_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

AGONES_EXPORT bool Scheme_IsValid(int value);
constexpr Scheme Scheme_MIN = static_cast<Scheme>(0);
constexpr Scheme Scheme_MAX = static_cast<Scheme>(4);
constexpr int Scheme_ARRAYSIZE = 4 + 1;
AGONES_EXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Scheme_descriptor();
template <typename T>
const std::string& Scheme_Name(T value) {
  static_assert(std::is_same<T, Scheme>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Scheme_Name().");
  return Scheme_Name(static_cast<Scheme>(value));
}
template <>
inline const std::string& Scheme_Name(Scheme value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Scheme_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool Scheme_Parse(absl::string_view name, Scheme* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Scheme>(
      Scheme_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Swagger_ResponsesEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Swagger_ResponsesEntry_DoNotUse, 
    std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Swagger_ResponsesEntry_DoNotUse, 
    std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Swagger_ResponsesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Swagger_ResponsesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Swagger_ResponsesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Swagger_ResponsesEntry_DoNotUse& other);
  static const Swagger_ResponsesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Swagger_ResponsesEntry_DoNotUse*>(&_Swagger_ResponsesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "grpc.gateway.protoc_gen_openapiv2.options.Swagger.ResponsesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};
// -------------------------------------------------------------------

class Swagger_ExtensionsEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Swagger_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Swagger_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Swagger_ExtensionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Swagger_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Swagger_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Swagger_ExtensionsEntry_DoNotUse& other);
  static const Swagger_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Swagger_ExtensionsEntry_DoNotUse*>(&_Swagger_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "grpc.gateway.protoc_gen_openapiv2.options.Swagger.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};
// -------------------------------------------------------------------

class AGONES_EXPORT Swagger final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.Swagger) */ {
 public:
  inline Swagger() : Swagger(nullptr) {}
  ~Swagger() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Swagger(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Swagger(const Swagger& from);
  Swagger(Swagger&& from) noexcept
    : Swagger() {
    *this = ::std::move(from);
  }

  inline Swagger& operator=(const Swagger& from) {
    CopyFrom(from);
    return *this;
  }
  inline Swagger& operator=(Swagger&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Swagger& default_instance() {
    return *internal_default_instance();
  }
  static inline const Swagger* internal_default_instance() {
    return reinterpret_cast<const Swagger*>(
               &_Swagger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Swagger& a, Swagger& b) {
    a.Swap(&b);
  }
  inline void Swap(Swagger* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Swagger* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Swagger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Swagger>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Swagger& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Swagger& from) {
    Swagger::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Swagger* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.Swagger";
  }
  protected:
  explicit Swagger(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSchemesFieldNumber = 5,
    kConsumesFieldNumber = 6,
    kProducesFieldNumber = 7,
    kResponsesFieldNumber = 10,
    kSecurityFieldNumber = 12,
    kExtensionsFieldNumber = 15,
    kSwaggerFieldNumber = 1,
    kHostFieldNumber = 3,
    kBasePathFieldNumber = 4,
    kInfoFieldNumber = 2,
    kSecurityDefinitionsFieldNumber = 11,
    kExternalDocsFieldNumber = 14,
  };
  // repeated .grpc.gateway.protoc_gen_openapiv2.options.Scheme schemes = 5;
  int schemes_size() const;
  private:
  int _internal_schemes_size() const;

  public:
  void clear_schemes() ;
  public:
  ::grpc::gateway::protoc_gen_openapiv2::options::Scheme schemes(int index) const;
  void set_schemes(int index, ::grpc::gateway::protoc_gen_openapiv2::options::Scheme value);
  void add_schemes(::grpc::gateway::protoc_gen_openapiv2::options::Scheme value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& schemes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_schemes();

  private:
  ::grpc::gateway::protoc_gen_openapiv2::options::Scheme _internal_schemes(int index) const;
  void _internal_add_schemes(::grpc::gateway::protoc_gen_openapiv2::options::Scheme value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& _internal_schemes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_schemes();

  public:
  // repeated string consumes = 6;
  int consumes_size() const;
  private:
  int _internal_consumes_size() const;

  public:
  void clear_consumes() ;
  const std::string& consumes(int index) const;
  std::string* mutable_consumes(int index);
  void set_consumes(int index, const std::string& value);
  void set_consumes(int index, std::string&& value);
  void set_consumes(int index, const char* value);
  void set_consumes(int index, const char* value, std::size_t size);
  void set_consumes(int index, absl::string_view value);
  std::string* add_consumes();
  void add_consumes(const std::string& value);
  void add_consumes(std::string&& value);
  void add_consumes(const char* value);
  void add_consumes(const char* value, std::size_t size);
  void add_consumes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& consumes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_consumes();

  private:
  const std::string& _internal_consumes(int index) const;
  std::string* _internal_add_consumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_consumes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_consumes();

  public:
  // repeated string produces = 7;
  int produces_size() const;
  private:
  int _internal_produces_size() const;

  public:
  void clear_produces() ;
  const std::string& produces(int index) const;
  std::string* mutable_produces(int index);
  void set_produces(int index, const std::string& value);
  void set_produces(int index, std::string&& value);
  void set_produces(int index, const char* value);
  void set_produces(int index, const char* value, std::size_t size);
  void set_produces(int index, absl::string_view value);
  std::string* add_produces();
  void add_produces(const std::string& value);
  void add_produces(std::string&& value);
  void add_produces(const char* value);
  void add_produces(const char* value, std::size_t size);
  void add_produces(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& produces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_produces();

  private:
  const std::string& _internal_produces(int index) const;
  std::string* _internal_add_produces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_produces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_produces();

  public:
  // map<string, .grpc.gateway.protoc_gen_openapiv2.options.Response> responses = 10;
  int responses_size() const;
  private:
  int _internal_responses_size() const;

  public:
  void clear_responses() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >&
      _internal_responses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >*
      _internal_mutable_responses();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >&
      responses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >*
      mutable_responses();
  // repeated .grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement security = 12;
  int security_size() const;
  private:
  int _internal_security_size() const;

  public:
  void clear_security() ;
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement* mutable_security(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement >*
      mutable_security();
  private:
  const ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement& _internal_security(int index) const;
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement* _internal_add_security();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement>& _internal_security() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement>* _internal_mutable_security();
  public:
  const ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement& security(int index) const;
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement* add_security();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement >&
      security() const;
  // map<string, .google.protobuf.Value> extensions = 15;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;

  public:
  void clear_extensions() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
      mutable_extensions();
  // string swagger = 1;
  void clear_swagger() ;
  const std::string& swagger() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_swagger(Arg_&& arg, Args_... args);
  std::string* mutable_swagger();
  PROTOBUF_NODISCARD std::string* release_swagger();
  void set_allocated_swagger(std::string* ptr);

  private:
  const std::string& _internal_swagger() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_swagger(
      const std::string& value);
  std::string* _internal_mutable_swagger();

  public:
  // string host = 3;
  void clear_host() ;
  const std::string& host() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_host(Arg_&& arg, Args_... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* ptr);

  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(
      const std::string& value);
  std::string* _internal_mutable_host();

  public:
  // string base_path = 4;
  void clear_base_path() ;
  const std::string& base_path() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_base_path(Arg_&& arg, Args_... args);
  std::string* mutable_base_path();
  PROTOBUF_NODISCARD std::string* release_base_path();
  void set_allocated_base_path(std::string* ptr);

  private:
  const std::string& _internal_base_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_path(
      const std::string& value);
  std::string* _internal_mutable_base_path();

  public:
  // .grpc.gateway.protoc_gen_openapiv2.options.Info info = 2;
  bool has_info() const;
  void clear_info() ;
  const ::grpc::gateway::protoc_gen_openapiv2::options::Info& info() const;
  PROTOBUF_NODISCARD ::grpc::gateway::protoc_gen_openapiv2::options::Info* release_info();
  ::grpc::gateway::protoc_gen_openapiv2::options::Info* mutable_info();
  void set_allocated_info(::grpc::gateway::protoc_gen_openapiv2::options::Info* info);
  private:
  const ::grpc::gateway::protoc_gen_openapiv2::options::Info& _internal_info() const;
  ::grpc::gateway::protoc_gen_openapiv2::options::Info* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::grpc::gateway::protoc_gen_openapiv2::options::Info* info);
  ::grpc::gateway::protoc_gen_openapiv2::options::Info* unsafe_arena_release_info();
  // .grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions security_definitions = 11;
  bool has_security_definitions() const;
  void clear_security_definitions() ;
  const ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions& security_definitions() const;
  PROTOBUF_NODISCARD ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* release_security_definitions();
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* mutable_security_definitions();
  void set_allocated_security_definitions(::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* security_definitions);
  private:
  const ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions& _internal_security_definitions() const;
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* _internal_mutable_security_definitions();
  public:
  void unsafe_arena_set_allocated_security_definitions(
      ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* security_definitions);
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* unsafe_arena_release_security_definitions();
  // .grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 14;
  bool has_external_docs() const;
  void clear_external_docs() ;
  const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& external_docs() const;
  PROTOBUF_NODISCARD ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* release_external_docs();
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* mutable_external_docs();
  void set_allocated_external_docs(::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs);
  private:
  const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& _internal_external_docs() const;
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* _internal_mutable_external_docs();
  public:
  void unsafe_arena_set_allocated_external_docs(
      ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs);
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* unsafe_arena_release_external_docs();
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.Swagger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> schemes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _schemes_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> consumes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> produces_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Swagger_ResponsesEntry_DoNotUse,
        std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> responses_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement > security_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Swagger_ExtensionsEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Value,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr swagger_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_path_;
    ::grpc::gateway::protoc_gen_openapiv2::options::Info* info_;
    ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* security_definitions_;
    ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class Operation_ResponsesEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Operation_ResponsesEntry_DoNotUse, 
    std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Operation_ResponsesEntry_DoNotUse, 
    std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Operation_ResponsesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Operation_ResponsesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Operation_ResponsesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Operation_ResponsesEntry_DoNotUse& other);
  static const Operation_ResponsesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Operation_ResponsesEntry_DoNotUse*>(&_Operation_ResponsesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "grpc.gateway.protoc_gen_openapiv2.options.Operation.ResponsesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};
// -------------------------------------------------------------------

class Operation_ExtensionsEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Operation_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Operation_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Operation_ExtensionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Operation_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Operation_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Operation_ExtensionsEntry_DoNotUse& other);
  static const Operation_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Operation_ExtensionsEntry_DoNotUse*>(&_Operation_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "grpc.gateway.protoc_gen_openapiv2.options.Operation.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};
// -------------------------------------------------------------------

class AGONES_EXPORT Operation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.Operation) */ {
 public:
  inline Operation() : Operation(nullptr) {}
  ~Operation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Operation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Operation(const Operation& from);
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operation& operator=(Operation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Operation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(Operation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Operation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Operation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Operation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Operation& from) {
    Operation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.Operation";
  }
  protected:
  explicit Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 1,
    kConsumesFieldNumber = 6,
    kProducesFieldNumber = 7,
    kResponsesFieldNumber = 9,
    kSchemesFieldNumber = 10,
    kSecurityFieldNumber = 12,
    kExtensionsFieldNumber = 13,
    kSummaryFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kOperationIdFieldNumber = 5,
    kExternalDocsFieldNumber = 4,
    kDeprecatedFieldNumber = 11,
  };
  // repeated string tags = 1;
  int tags_size() const;
  private:
  int _internal_tags_size() const;

  public:
  void clear_tags() ;
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, std::size_t size);
  void set_tags(int index, absl::string_view value);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, std::size_t size);
  void add_tags(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();

  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_tags();

  public:
  // repeated string consumes = 6;
  int consumes_size() const;
  private:
  int _internal_consumes_size() const;

  public:
  void clear_consumes() ;
  const std::string& consumes(int index) const;
  std::string* mutable_consumes(int index);
  void set_consumes(int index, const std::string& value);
  void set_consumes(int index, std::string&& value);
  void set_consumes(int index, const char* value);
  void set_consumes(int index, const char* value, std::size_t size);
  void set_consumes(int index, absl::string_view value);
  std::string* add_consumes();
  void add_consumes(const std::string& value);
  void add_consumes(std::string&& value);
  void add_consumes(const char* value);
  void add_consumes(const char* value, std::size_t size);
  void add_consumes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& consumes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_consumes();

  private:
  const std::string& _internal_consumes(int index) const;
  std::string* _internal_add_consumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_consumes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_consumes();

  public:
  // repeated string produces = 7;
  int produces_size() const;
  private:
  int _internal_produces_size() const;

  public:
  void clear_produces() ;
  const std::string& produces(int index) const;
  std::string* mutable_produces(int index);
  void set_produces(int index, const std::string& value);
  void set_produces(int index, std::string&& value);
  void set_produces(int index, const char* value);
  void set_produces(int index, const char* value, std::size_t size);
  void set_produces(int index, absl::string_view value);
  std::string* add_produces();
  void add_produces(const std::string& value);
  void add_produces(std::string&& value);
  void add_produces(const char* value);
  void add_produces(const char* value, std::size_t size);
  void add_produces(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& produces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_produces();

  private:
  const std::string& _internal_produces(int index) const;
  std::string* _internal_add_produces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_produces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_produces();

  public:
  // map<string, .grpc.gateway.protoc_gen_openapiv2.options.Response> responses = 9;
  int responses_size() const;
  private:
  int _internal_responses_size() const;

  public:
  void clear_responses() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >&
      _internal_responses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >*
      _internal_mutable_responses();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >&
      responses() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >*
      mutable_responses();
  // repeated .grpc.gateway.protoc_gen_openapiv2.options.Scheme schemes = 10;
  int schemes_size() const;
  private:
  int _internal_schemes_size() const;

  public:
  void clear_schemes() ;
  public:
  ::grpc::gateway::protoc_gen_openapiv2::options::Scheme schemes(int index) const;
  void set_schemes(int index, ::grpc::gateway::protoc_gen_openapiv2::options::Scheme value);
  void add_schemes(::grpc::gateway::protoc_gen_openapiv2::options::Scheme value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& schemes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_schemes();

  private:
  ::grpc::gateway::protoc_gen_openapiv2::options::Scheme _internal_schemes(int index) const;
  void _internal_add_schemes(::grpc::gateway::protoc_gen_openapiv2::options::Scheme value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& _internal_schemes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_schemes();

  public:
  // repeated .grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement security = 12;
  int security_size() const;
  private:
  int _internal_security_size() const;

  public:
  void clear_security() ;
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement* mutable_security(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement >*
      mutable_security();
  private:
  const ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement& _internal_security(int index) const;
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement* _internal_add_security();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement>& _internal_security() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement>* _internal_mutable_security();
  public:
  const ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement& security(int index) const;
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement* add_security();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement >&
      security() const;
  // map<string, .google.protobuf.Value> extensions = 13;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;

  public:
  void clear_extensions() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
      mutable_extensions();
  // string summary = 2;
  void clear_summary() ;
  const std::string& summary() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_summary(Arg_&& arg, Args_... args);
  std::string* mutable_summary();
  PROTOBUF_NODISCARD std::string* release_summary();
  void set_allocated_summary(std::string* ptr);

  private:
  const std::string& _internal_summary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_summary(
      const std::string& value);
  std::string* _internal_mutable_summary();

  public:
  // string description = 3;
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string operation_id = 5;
  void clear_operation_id() ;
  const std::string& operation_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_id(Arg_&& arg, Args_... args);
  std::string* mutable_operation_id();
  PROTOBUF_NODISCARD std::string* release_operation_id();
  void set_allocated_operation_id(std::string* ptr);

  private:
  const std::string& _internal_operation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_id(
      const std::string& value);
  std::string* _internal_mutable_operation_id();

  public:
  // .grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 4;
  bool has_external_docs() const;
  void clear_external_docs() ;
  const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& external_docs() const;
  PROTOBUF_NODISCARD ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* release_external_docs();
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* mutable_external_docs();
  void set_allocated_external_docs(::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs);
  private:
  const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& _internal_external_docs() const;
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* _internal_mutable_external_docs();
  public:
  void unsafe_arena_set_allocated_external_docs(
      ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs);
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* unsafe_arena_release_external_docs();
  // bool deprecated = 11;
  void clear_deprecated() ;
  bool deprecated() const;
  void set_deprecated(bool value);

  private:
  bool _internal_deprecated() const;
  void _internal_set_deprecated(bool value);

  public:
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.Operation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> consumes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> produces_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Operation_ResponsesEntry_DoNotUse,
        std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> responses_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> schemes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _schemes_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement > security_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Operation_ExtensionsEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Value,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr summary_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_id_;
    ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs_;
    bool deprecated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class AGONES_EXPORT Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Header& from) {
    Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 1,
    kTypeFieldNumber = 2,
    kFormatFieldNumber = 3,
    kDefaultFieldNumber = 6,
    kPatternFieldNumber = 13,
  };
  // string description = 1;
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string type = 2;
  void clear_type() ;
  const std::string& type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string format = 3;
  void clear_format() ;
  const std::string& format() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_format(Arg_&& arg, Args_... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* ptr);

  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(
      const std::string& value);
  std::string* _internal_mutable_format();

  public:
  // string default = 6;
  void clear_default_() ;
  const std::string& default_() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_(Arg_&& arg, Args_... args);
  std::string* mutable_default_();
  PROTOBUF_NODISCARD std::string* release_default_();
  void set_allocated_default_(std::string* ptr);

  private:
  const std::string& _internal_default_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_(
      const std::string& value);
  std::string* _internal_mutable_default_();

  public:
  // string pattern = 13;
  void clear_pattern() ;
  const std::string& pattern() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_pattern();
  PROTOBUF_NODISCARD std::string* release_pattern();
  void set_allocated_pattern(std::string* ptr);

  private:
  const std::string& _internal_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(
      const std::string& value);
  std::string* _internal_mutable_pattern();

  public:
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pattern_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class Response_HeadersEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Response_HeadersEntry_DoNotUse, 
    std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Header,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Response_HeadersEntry_DoNotUse, 
    std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Header,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Response_HeadersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Response_HeadersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Response_HeadersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Response_HeadersEntry_DoNotUse& other);
  static const Response_HeadersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Response_HeadersEntry_DoNotUse*>(&_Response_HeadersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "grpc.gateway.protoc_gen_openapiv2.options.Response.HeadersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};
// -------------------------------------------------------------------

class Response_ExamplesEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Response_ExamplesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Response_ExamplesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Response_ExamplesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Response_ExamplesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Response_ExamplesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Response_ExamplesEntry_DoNotUse& other);
  static const Response_ExamplesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Response_ExamplesEntry_DoNotUse*>(&_Response_ExamplesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "grpc.gateway.protoc_gen_openapiv2.options.Response.ExamplesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "grpc.gateway.protoc_gen_openapiv2.options.Response.ExamplesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};
// -------------------------------------------------------------------

class Response_ExtensionsEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Response_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Response_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Response_ExtensionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Response_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Response_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Response_ExtensionsEntry_DoNotUse& other);
  static const Response_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Response_ExtensionsEntry_DoNotUse*>(&_Response_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "grpc.gateway.protoc_gen_openapiv2.options.Response.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};
// -------------------------------------------------------------------

class AGONES_EXPORT Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kHeadersFieldNumber = 3,
    kExamplesFieldNumber = 4,
    kExtensionsFieldNumber = 5,
    kDescriptionFieldNumber = 1,
    kSchemaFieldNumber = 2,
  };
  // map<string, .grpc.gateway.protoc_gen_openapiv2.options.Header> headers = 3;
  int headers_size() const;
  private:
  int _internal_headers_size() const;

  public:
  void clear_headers() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Header >&
      _internal_headers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Header >*
      _internal_mutable_headers();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Header >&
      headers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Header >*
      mutable_headers();
  // map<string, string> examples = 4;
  int examples_size() const;
  private:
  int _internal_examples_size() const;

  public:
  void clear_examples() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_examples() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_examples();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      examples() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_examples();
  // map<string, .google.protobuf.Value> extensions = 5;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;

  public:
  void clear_extensions() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
      mutable_extensions();
  // string description = 1;
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .grpc.gateway.protoc_gen_openapiv2.options.Schema schema = 2;
  bool has_schema() const;
  void clear_schema() ;
  const ::grpc::gateway::protoc_gen_openapiv2::options::Schema& schema() const;
  PROTOBUF_NODISCARD ::grpc::gateway::protoc_gen_openapiv2::options::Schema* release_schema();
  ::grpc::gateway::protoc_gen_openapiv2::options::Schema* mutable_schema();
  void set_allocated_schema(::grpc::gateway::protoc_gen_openapiv2::options::Schema* schema);
  private:
  const ::grpc::gateway::protoc_gen_openapiv2::options::Schema& _internal_schema() const;
  ::grpc::gateway::protoc_gen_openapiv2::options::Schema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::grpc::gateway::protoc_gen_openapiv2::options::Schema* schema);
  ::grpc::gateway::protoc_gen_openapiv2::options::Schema* unsafe_arena_release_schema();
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Response_HeadersEntry_DoNotUse,
        std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Header,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> headers_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Response_ExamplesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> examples_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Response_ExtensionsEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Value,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::grpc::gateway::protoc_gen_openapiv2::options::Schema* schema_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class Info_ExtensionsEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Info_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Info_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Info_ExtensionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Info_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Info_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Info_ExtensionsEntry_DoNotUse& other);
  static const Info_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Info_ExtensionsEntry_DoNotUse*>(&_Info_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "grpc.gateway.protoc_gen_openapiv2.options.Info.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};
// -------------------------------------------------------------------

class AGONES_EXPORT Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.Info) */ {
 public:
  inline Info() : Info(nullptr) {}
  ~Info() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Info(const Info& from);
  Info(Info&& from) noexcept
    : Info() {
    *this = ::std::move(from);
  }

  inline Info& operator=(const Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Info& operator=(Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Info* internal_default_instance() {
    return reinterpret_cast<const Info*>(
               &_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Info& a, Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Info* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Info& from) {
    Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.Info";
  }
  protected:
  explicit Info(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtensionsFieldNumber = 7,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kTermsOfServiceFieldNumber = 3,
    kVersionFieldNumber = 6,
    kContactFieldNumber = 4,
    kLicenseFieldNumber = 5,
  };
  // map<string, .google.protobuf.Value> extensions = 7;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;

  public:
  void clear_extensions() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
      mutable_extensions();
  // string title = 1;
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2;
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string terms_of_service = 3;
  void clear_terms_of_service() ;
  const std::string& terms_of_service() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_terms_of_service(Arg_&& arg, Args_... args);
  std::string* mutable_terms_of_service();
  PROTOBUF_NODISCARD std::string* release_terms_of_service();
  void set_allocated_terms_of_service(std::string* ptr);

  private:
  const std::string& _internal_terms_of_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_terms_of_service(
      const std::string& value);
  std::string* _internal_mutable_terms_of_service();

  public:
  // string version = 6;
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // .grpc.gateway.protoc_gen_openapiv2.options.Contact contact = 4;
  bool has_contact() const;
  void clear_contact() ;
  const ::grpc::gateway::protoc_gen_openapiv2::options::Contact& contact() const;
  PROTOBUF_NODISCARD ::grpc::gateway::protoc_gen_openapiv2::options::Contact* release_contact();
  ::grpc::gateway::protoc_gen_openapiv2::options::Contact* mutable_contact();
  void set_allocated_contact(::grpc::gateway::protoc_gen_openapiv2::options::Contact* contact);
  private:
  const ::grpc::gateway::protoc_gen_openapiv2::options::Contact& _internal_contact() const;
  ::grpc::gateway::protoc_gen_openapiv2::options::Contact* _internal_mutable_contact();
  public:
  void unsafe_arena_set_allocated_contact(
      ::grpc::gateway::protoc_gen_openapiv2::options::Contact* contact);
  ::grpc::gateway::protoc_gen_openapiv2::options::Contact* unsafe_arena_release_contact();
  // .grpc.gateway.protoc_gen_openapiv2.options.License license = 5;
  bool has_license() const;
  void clear_license() ;
  const ::grpc::gateway::protoc_gen_openapiv2::options::License& license() const;
  PROTOBUF_NODISCARD ::grpc::gateway::protoc_gen_openapiv2::options::License* release_license();
  ::grpc::gateway::protoc_gen_openapiv2::options::License* mutable_license();
  void set_allocated_license(::grpc::gateway::protoc_gen_openapiv2::options::License* license);
  private:
  const ::grpc::gateway::protoc_gen_openapiv2::options::License& _internal_license() const;
  ::grpc::gateway::protoc_gen_openapiv2::options::License* _internal_mutable_license();
  public:
  void unsafe_arena_set_allocated_license(
      ::grpc::gateway::protoc_gen_openapiv2::options::License* license);
  ::grpc::gateway::protoc_gen_openapiv2::options::License* unsafe_arena_release_license();
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.Info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Info_ExtensionsEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Value,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr terms_of_service_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::grpc::gateway::protoc_gen_openapiv2::options::Contact* contact_;
    ::grpc::gateway::protoc_gen_openapiv2::options::License* license_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class AGONES_EXPORT Contact final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.Contact) */ {
 public:
  inline Contact() : Contact(nullptr) {}
  ~Contact() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Contact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Contact(const Contact& from);
  Contact(Contact&& from) noexcept
    : Contact() {
    *this = ::std::move(from);
  }

  inline Contact& operator=(const Contact& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contact& operator=(Contact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Contact& default_instance() {
    return *internal_default_instance();
  }
  static inline const Contact* internal_default_instance() {
    return reinterpret_cast<const Contact*>(
               &_Contact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Contact& a, Contact& b) {
    a.Swap(&b);
  }
  inline void Swap(Contact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contact* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Contact>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Contact& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Contact& from) {
    Contact::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Contact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.Contact";
  }
  protected:
  explicit Contact(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kUrlFieldNumber = 2,
    kEmailFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string url = 2;
  void clear_url() ;
  const std::string& url() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* ptr);

  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(
      const std::string& value);
  std::string* _internal_mutable_url();

  public:
  // string email = 3;
  void clear_email() ;
  const std::string& email() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* ptr);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.Contact)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class AGONES_EXPORT License final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.License) */ {
 public:
  inline License() : License(nullptr) {}
  ~License() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR License(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  License(const License& from);
  License(License&& from) noexcept
    : License() {
    *this = ::std::move(from);
  }

  inline License& operator=(const License& from) {
    CopyFrom(from);
    return *this;
  }
  inline License& operator=(License&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const License& default_instance() {
    return *internal_default_instance();
  }
  static inline const License* internal_default_instance() {
    return reinterpret_cast<const License*>(
               &_License_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(License& a, License& b) {
    a.Swap(&b);
  }
  inline void Swap(License* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(License* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  License* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<License>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const License& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const License& from) {
    License::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(License* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.License";
  }
  protected:
  explicit License(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kUrlFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string url = 2;
  void clear_url() ;
  const std::string& url() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* ptr);

  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(
      const std::string& value);
  std::string* _internal_mutable_url();

  public:
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.License)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class AGONES_EXPORT ExternalDocumentation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation) */ {
 public:
  inline ExternalDocumentation() : ExternalDocumentation(nullptr) {}
  ~ExternalDocumentation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExternalDocumentation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExternalDocumentation(const ExternalDocumentation& from);
  ExternalDocumentation(ExternalDocumentation&& from) noexcept
    : ExternalDocumentation() {
    *this = ::std::move(from);
  }

  inline ExternalDocumentation& operator=(const ExternalDocumentation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalDocumentation& operator=(ExternalDocumentation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExternalDocumentation& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalDocumentation* internal_default_instance() {
    return reinterpret_cast<const ExternalDocumentation*>(
               &_ExternalDocumentation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ExternalDocumentation& a, ExternalDocumentation& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternalDocumentation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalDocumentation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalDocumentation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExternalDocumentation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExternalDocumentation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExternalDocumentation& from) {
    ExternalDocumentation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExternalDocumentation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation";
  }
  protected:
  explicit ExternalDocumentation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 1,
    kUrlFieldNumber = 2,
  };
  // string description = 1;
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string url = 2;
  void clear_url() ;
  const std::string& url() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* ptr);

  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(
      const std::string& value);
  std::string* _internal_mutable_url();

  public:
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class AGONES_EXPORT Schema final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.Schema) */ {
 public:
  inline Schema() : Schema(nullptr) {}
  ~Schema() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Schema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Schema(const Schema& from);
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  inline Schema& operator=(Schema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Schema& default_instance() {
    return *internal_default_instance();
  }
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }
  inline void Swap(Schema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Schema* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Schema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Schema& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Schema& from) {
    Schema::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schema* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.Schema";
  }
  protected:
  explicit Schema(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiscriminatorFieldNumber = 2,
    kExampleFieldNumber = 6,
    kJsonSchemaFieldNumber = 1,
    kExternalDocsFieldNumber = 5,
    kReadOnlyFieldNumber = 3,
  };
  // string discriminator = 2;
  void clear_discriminator() ;
  const std::string& discriminator() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_discriminator(Arg_&& arg, Args_... args);
  std::string* mutable_discriminator();
  PROTOBUF_NODISCARD std::string* release_discriminator();
  void set_allocated_discriminator(std::string* ptr);

  private:
  const std::string& _internal_discriminator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_discriminator(
      const std::string& value);
  std::string* _internal_mutable_discriminator();

  public:
  // string example = 6;
  void clear_example() ;
  const std::string& example() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_example(Arg_&& arg, Args_... args);
  std::string* mutable_example();
  PROTOBUF_NODISCARD std::string* release_example();
  void set_allocated_example(std::string* ptr);

  private:
  const std::string& _internal_example() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_example(
      const std::string& value);
  std::string* _internal_mutable_example();

  public:
  // .grpc.gateway.protoc_gen_openapiv2.options.JSONSchema json_schema = 1;
  bool has_json_schema() const;
  void clear_json_schema() ;
  const ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema& json_schema() const;
  PROTOBUF_NODISCARD ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* release_json_schema();
  ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* mutable_json_schema();
  void set_allocated_json_schema(::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* json_schema);
  private:
  const ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema& _internal_json_schema() const;
  ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* _internal_mutable_json_schema();
  public:
  void unsafe_arena_set_allocated_json_schema(
      ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* json_schema);
  ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* unsafe_arena_release_json_schema();
  // .grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 5;
  bool has_external_docs() const;
  void clear_external_docs() ;
  const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& external_docs() const;
  PROTOBUF_NODISCARD ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* release_external_docs();
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* mutable_external_docs();
  void set_allocated_external_docs(::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs);
  private:
  const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& _internal_external_docs() const;
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* _internal_mutable_external_docs();
  public:
  void unsafe_arena_set_allocated_external_docs(
      ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs);
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* unsafe_arena_release_external_docs();
  // bool read_only = 3;
  void clear_read_only() ;
  bool read_only() const;
  void set_read_only(bool value);

  private:
  bool _internal_read_only() const;
  void _internal_set_read_only(bool value);

  public:
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.Schema)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr discriminator_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr example_;
    ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* json_schema_;
    ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs_;
    bool read_only_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class AGONES_EXPORT JSONSchema_FieldConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration) */ {
 public:
  inline JSONSchema_FieldConfiguration() : JSONSchema_FieldConfiguration(nullptr) {}
  ~JSONSchema_FieldConfiguration() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JSONSchema_FieldConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JSONSchema_FieldConfiguration(const JSONSchema_FieldConfiguration& from);
  JSONSchema_FieldConfiguration(JSONSchema_FieldConfiguration&& from) noexcept
    : JSONSchema_FieldConfiguration() {
    *this = ::std::move(from);
  }

  inline JSONSchema_FieldConfiguration& operator=(const JSONSchema_FieldConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline JSONSchema_FieldConfiguration& operator=(JSONSchema_FieldConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JSONSchema_FieldConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const JSONSchema_FieldConfiguration* internal_default_instance() {
    return reinterpret_cast<const JSONSchema_FieldConfiguration*>(
               &_JSONSchema_FieldConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(JSONSchema_FieldConfiguration& a, JSONSchema_FieldConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(JSONSchema_FieldConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JSONSchema_FieldConfiguration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JSONSchema_FieldConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JSONSchema_FieldConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JSONSchema_FieldConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JSONSchema_FieldConfiguration& from) {
    JSONSchema_FieldConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONSchema_FieldConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration";
  }
  protected:
  explicit JSONSchema_FieldConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathParamNameFieldNumber = 47,
  };
  // string path_param_name = 47;
  void clear_path_param_name() ;
  const std::string& path_param_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path_param_name(Arg_&& arg, Args_... args);
  std::string* mutable_path_param_name();
  PROTOBUF_NODISCARD std::string* release_path_param_name();
  void set_allocated_path_param_name(std::string* ptr);

  private:
  const std::string& _internal_path_param_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path_param_name(
      const std::string& value);
  std::string* _internal_mutable_path_param_name();

  public:
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_param_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class JSONSchema_ExtensionsEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JSONSchema_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JSONSchema_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  JSONSchema_ExtensionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR JSONSchema_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit JSONSchema_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const JSONSchema_ExtensionsEntry_DoNotUse& other);
  static const JSONSchema_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const JSONSchema_ExtensionsEntry_DoNotUse*>(&_JSONSchema_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};
// -------------------------------------------------------------------

class AGONES_EXPORT JSONSchema final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema) */ {
 public:
  inline JSONSchema() : JSONSchema(nullptr) {}
  ~JSONSchema() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JSONSchema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JSONSchema(const JSONSchema& from);
  JSONSchema(JSONSchema&& from) noexcept
    : JSONSchema() {
    *this = ::std::move(from);
  }

  inline JSONSchema& operator=(const JSONSchema& from) {
    CopyFrom(from);
    return *this;
  }
  inline JSONSchema& operator=(JSONSchema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JSONSchema& default_instance() {
    return *internal_default_instance();
  }
  static inline const JSONSchema* internal_default_instance() {
    return reinterpret_cast<const JSONSchema*>(
               &_JSONSchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(JSONSchema& a, JSONSchema& b) {
    a.Swap(&b);
  }
  inline void Swap(JSONSchema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JSONSchema* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JSONSchema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JSONSchema>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JSONSchema& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JSONSchema& from) {
    JSONSchema::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JSONSchema* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.JSONSchema";
  }
  protected:
  explicit JSONSchema(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef JSONSchema_FieldConfiguration FieldConfiguration;

  using JSONSchemaSimpleTypes = JSONSchema_JSONSchemaSimpleTypes;
  static constexpr JSONSchemaSimpleTypes UNKNOWN = JSONSchema_JSONSchemaSimpleTypes_UNKNOWN;
  static constexpr JSONSchemaSimpleTypes ARRAY = JSONSchema_JSONSchemaSimpleTypes_ARRAY;
  static constexpr JSONSchemaSimpleTypes BOOLEAN = JSONSchema_JSONSchemaSimpleTypes_BOOLEAN;
  static constexpr JSONSchemaSimpleTypes INTEGER = JSONSchema_JSONSchemaSimpleTypes_INTEGER;
  static constexpr JSONSchemaSimpleTypes NULL_ = JSONSchema_JSONSchemaSimpleTypes_NULL_;
  static constexpr JSONSchemaSimpleTypes NUMBER = JSONSchema_JSONSchemaSimpleTypes_NUMBER;
  static constexpr JSONSchemaSimpleTypes OBJECT = JSONSchema_JSONSchemaSimpleTypes_OBJECT;
  static constexpr JSONSchemaSimpleTypes STRING = JSONSchema_JSONSchemaSimpleTypes_STRING;
  static inline bool JSONSchemaSimpleTypes_IsValid(int value) {
    return JSONSchema_JSONSchemaSimpleTypes_IsValid(value);
  }
  static constexpr JSONSchemaSimpleTypes JSONSchemaSimpleTypes_MIN = JSONSchema_JSONSchemaSimpleTypes_JSONSchemaSimpleTypes_MIN;
  static constexpr JSONSchemaSimpleTypes JSONSchemaSimpleTypes_MAX = JSONSchema_JSONSchemaSimpleTypes_JSONSchemaSimpleTypes_MAX;
  static constexpr int JSONSchemaSimpleTypes_ARRAYSIZE = JSONSchema_JSONSchemaSimpleTypes_JSONSchemaSimpleTypes_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JSONSchemaSimpleTypes_descriptor() {
    return JSONSchema_JSONSchemaSimpleTypes_descriptor();
  }
  template <typename T>
  static inline const std::string& JSONSchemaSimpleTypes_Name(T value) {
    return JSONSchema_JSONSchemaSimpleTypes_Name(value);
  }
  static inline bool JSONSchemaSimpleTypes_Parse(absl::string_view name, JSONSchemaSimpleTypes* value) {
    return JSONSchema_JSONSchemaSimpleTypes_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredFieldNumber = 26,
    kArrayFieldNumber = 34,
    kTypeFieldNumber = 35,
    kEnumFieldNumber = 46,
    kExtensionsFieldNumber = 48,
    kRefFieldNumber = 3,
    kTitleFieldNumber = 5,
    kDescriptionFieldNumber = 6,
    kDefaultFieldNumber = 7,
    kExampleFieldNumber = 9,
    kPatternFieldNumber = 17,
    kFormatFieldNumber = 36,
    kFieldConfigurationFieldNumber = 1001,
    kMultipleOfFieldNumber = 10,
    kMaximumFieldNumber = 11,
    kMinimumFieldNumber = 13,
    kMaxLengthFieldNumber = 15,
    kMinLengthFieldNumber = 16,
    kMaxItemsFieldNumber = 20,
    kMinItemsFieldNumber = 21,
    kMaxPropertiesFieldNumber = 24,
    kMinPropertiesFieldNumber = 25,
    kReadOnlyFieldNumber = 8,
    kExclusiveMaximumFieldNumber = 12,
    kExclusiveMinimumFieldNumber = 14,
    kUniqueItemsFieldNumber = 22,
  };
  // repeated string required = 26;
  int required_size() const;
  private:
  int _internal_required_size() const;

  public:
  void clear_required() ;
  const std::string& required(int index) const;
  std::string* mutable_required(int index);
  void set_required(int index, const std::string& value);
  void set_required(int index, std::string&& value);
  void set_required(int index, const char* value);
  void set_required(int index, const char* value, std::size_t size);
  void set_required(int index, absl::string_view value);
  std::string* add_required();
  void add_required(const std::string& value);
  void add_required(std::string&& value);
  void add_required(const char* value);
  void add_required(const char* value, std::size_t size);
  void add_required(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& required() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_required();

  private:
  const std::string& _internal_required(int index) const;
  std::string* _internal_add_required();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_required() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_required();

  public:
  // repeated string array = 34;
  int array_size() const;
  private:
  int _internal_array_size() const;

  public:
  void clear_array() ;
  const std::string& array(int index) const;
  std::string* mutable_array(int index);
  void set_array(int index, const std::string& value);
  void set_array(int index, std::string&& value);
  void set_array(int index, const char* value);
  void set_array(int index, const char* value, std::size_t size);
  void set_array(int index, absl::string_view value);
  std::string* add_array();
  void add_array(const std::string& value);
  void add_array(std::string&& value);
  void add_array(const char* value);
  void add_array(const char* value, std::size_t size);
  void add_array(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& array() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_array();

  private:
  const std::string& _internal_array(int index) const;
  std::string* _internal_add_array();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_array() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_array();

  public:
  // repeated .grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.JSONSchemaSimpleTypes type = 35;
  int type_size() const;
  private:
  int _internal_type_size() const;

  public:
  void clear_type() ;
  public:
  ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_JSONSchemaSimpleTypes type(int index) const;
  void set_type(int index, ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_JSONSchemaSimpleTypes value);
  void add_type(::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_JSONSchemaSimpleTypes value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_type();

  private:
  ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_JSONSchemaSimpleTypes _internal_type(int index) const;
  void _internal_add_type(::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_JSONSchemaSimpleTypes value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& _internal_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_type();

  public:
  // repeated string enum = 46;
  int enum__size() const;
  private:
  int _internal_enum__size() const;

  public:
  void clear_enum_() ;
  const std::string& enum_(int index) const;
  std::string* mutable_enum_(int index);
  void set_enum_(int index, const std::string& value);
  void set_enum_(int index, std::string&& value);
  void set_enum_(int index, const char* value);
  void set_enum_(int index, const char* value, std::size_t size);
  void set_enum_(int index, absl::string_view value);
  std::string* add_enum_();
  void add_enum_(const std::string& value);
  void add_enum_(std::string&& value);
  void add_enum_(const char* value);
  void add_enum_(const char* value, std::size_t size);
  void add_enum_(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& enum_() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_enum_();

  private:
  const std::string& _internal_enum_(int index) const;
  std::string* _internal_add_enum_();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_enum_() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_enum_();

  public:
  // map<string, .google.protobuf.Value> extensions = 48;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;

  public:
  void clear_extensions() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
      mutable_extensions();
  // string ref = 3;
  void clear_ref() ;
  const std::string& ref() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ref(Arg_&& arg, Args_... args);
  std::string* mutable_ref();
  PROTOBUF_NODISCARD std::string* release_ref();
  void set_allocated_ref(std::string* ptr);

  private:
  const std::string& _internal_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ref(
      const std::string& value);
  std::string* _internal_mutable_ref();

  public:
  // string title = 5;
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 6;
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string default = 7;
  void clear_default_() ;
  const std::string& default_() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_(Arg_&& arg, Args_... args);
  std::string* mutable_default_();
  PROTOBUF_NODISCARD std::string* release_default_();
  void set_allocated_default_(std::string* ptr);

  private:
  const std::string& _internal_default_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_(
      const std::string& value);
  std::string* _internal_mutable_default_();

  public:
  // string example = 9;
  void clear_example() ;
  const std::string& example() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_example(Arg_&& arg, Args_... args);
  std::string* mutable_example();
  PROTOBUF_NODISCARD std::string* release_example();
  void set_allocated_example(std::string* ptr);

  private:
  const std::string& _internal_example() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_example(
      const std::string& value);
  std::string* _internal_mutable_example();

  public:
  // string pattern = 17;
  void clear_pattern() ;
  const std::string& pattern() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_pattern();
  PROTOBUF_NODISCARD std::string* release_pattern();
  void set_allocated_pattern(std::string* ptr);

  private:
  const std::string& _internal_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(
      const std::string& value);
  std::string* _internal_mutable_pattern();

  public:
  // string format = 36;
  void clear_format() ;
  const std::string& format() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_format(Arg_&& arg, Args_... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* ptr);

  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(
      const std::string& value);
  std::string* _internal_mutable_format();

  public:
  // .grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration field_configuration = 1001;
  bool has_field_configuration() const;
  void clear_field_configuration() ;
  const ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration& field_configuration() const;
  PROTOBUF_NODISCARD ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* release_field_configuration();
  ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* mutable_field_configuration();
  void set_allocated_field_configuration(::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* field_configuration);
  private:
  const ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration& _internal_field_configuration() const;
  ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* _internal_mutable_field_configuration();
  public:
  void unsafe_arena_set_allocated_field_configuration(
      ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* field_configuration);
  ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* unsafe_arena_release_field_configuration();
  // double multiple_of = 10;
  void clear_multiple_of() ;
  double multiple_of() const;
  void set_multiple_of(double value);

  private:
  double _internal_multiple_of() const;
  void _internal_set_multiple_of(double value);

  public:
  // double maximum = 11;
  void clear_maximum() ;
  double maximum() const;
  void set_maximum(double value);

  private:
  double _internal_maximum() const;
  void _internal_set_maximum(double value);

  public:
  // double minimum = 13;
  void clear_minimum() ;
  double minimum() const;
  void set_minimum(double value);

  private:
  double _internal_minimum() const;
  void _internal_set_minimum(double value);

  public:
  // uint64 max_length = 15;
  void clear_max_length() ;
  ::uint64_t max_length() const;
  void set_max_length(::uint64_t value);

  private:
  ::uint64_t _internal_max_length() const;
  void _internal_set_max_length(::uint64_t value);

  public:
  // uint64 min_length = 16;
  void clear_min_length() ;
  ::uint64_t min_length() const;
  void set_min_length(::uint64_t value);

  private:
  ::uint64_t _internal_min_length() const;
  void _internal_set_min_length(::uint64_t value);

  public:
  // uint64 max_items = 20;
  void clear_max_items() ;
  ::uint64_t max_items() const;
  void set_max_items(::uint64_t value);

  private:
  ::uint64_t _internal_max_items() const;
  void _internal_set_max_items(::uint64_t value);

  public:
  // uint64 min_items = 21;
  void clear_min_items() ;
  ::uint64_t min_items() const;
  void set_min_items(::uint64_t value);

  private:
  ::uint64_t _internal_min_items() const;
  void _internal_set_min_items(::uint64_t value);

  public:
  // uint64 max_properties = 24;
  void clear_max_properties() ;
  ::uint64_t max_properties() const;
  void set_max_properties(::uint64_t value);

  private:
  ::uint64_t _internal_max_properties() const;
  void _internal_set_max_properties(::uint64_t value);

  public:
  // uint64 min_properties = 25;
  void clear_min_properties() ;
  ::uint64_t min_properties() const;
  void set_min_properties(::uint64_t value);

  private:
  ::uint64_t _internal_min_properties() const;
  void _internal_set_min_properties(::uint64_t value);

  public:
  // bool read_only = 8;
  void clear_read_only() ;
  bool read_only() const;
  void set_read_only(bool value);

  private:
  bool _internal_read_only() const;
  void _internal_set_read_only(bool value);

  public:
  // bool exclusive_maximum = 12;
  void clear_exclusive_maximum() ;
  bool exclusive_maximum() const;
  void set_exclusive_maximum(bool value);

  private:
  bool _internal_exclusive_maximum() const;
  void _internal_set_exclusive_maximum(bool value);

  public:
  // bool exclusive_minimum = 14;
  void clear_exclusive_minimum() ;
  bool exclusive_minimum() const;
  void set_exclusive_minimum(bool value);

  private:
  bool _internal_exclusive_minimum() const;
  void _internal_set_exclusive_minimum(bool value);

  public:
  // bool unique_items = 22;
  void clear_unique_items() ;
  bool unique_items() const;
  void set_unique_items(bool value);

  private:
  bool _internal_unique_items() const;
  void _internal_set_unique_items(bool value);

  public:
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> required_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> array_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _type_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> enum__;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        JSONSchema_ExtensionsEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Value,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ref_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr example_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pattern_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
    ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* field_configuration_;
    double multiple_of_;
    double maximum_;
    double minimum_;
    ::uint64_t max_length_;
    ::uint64_t min_length_;
    ::uint64_t max_items_;
    ::uint64_t min_items_;
    ::uint64_t max_properties_;
    ::uint64_t min_properties_;
    bool read_only_;
    bool exclusive_maximum_;
    bool exclusive_minimum_;
    bool unique_items_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class AGONES_EXPORT Tag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.Tag) */ {
 public:
  inline Tag() : Tag(nullptr) {}
  ~Tag() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Tag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tag(const Tag& from);
  Tag(Tag&& from) noexcept
    : Tag() {
    *this = ::std::move(from);
  }

  inline Tag& operator=(const Tag& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tag& operator=(Tag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tag& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tag* internal_default_instance() {
    return reinterpret_cast<const Tag*>(
               &_Tag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Tag& a, Tag& b) {
    a.Swap(&b);
  }
  inline void Swap(Tag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tag* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tag& from) {
    Tag::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.Tag";
  }
  protected:
  explicit Tag(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kExternalDocsFieldNumber = 3,
  };
  // string description = 2;
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 3;
  bool has_external_docs() const;
  void clear_external_docs() ;
  const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& external_docs() const;
  PROTOBUF_NODISCARD ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* release_external_docs();
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* mutable_external_docs();
  void set_allocated_external_docs(::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs);
  private:
  const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& _internal_external_docs() const;
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* _internal_mutable_external_docs();
  public:
  void unsafe_arena_set_allocated_external_docs(
      ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs);
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* unsafe_arena_release_external_docs();
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.Tag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class SecurityDefinitions_SecurityEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SecurityDefinitions_SecurityEntry_DoNotUse, 
    std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SecurityDefinitions_SecurityEntry_DoNotUse, 
    std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SecurityDefinitions_SecurityEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SecurityDefinitions_SecurityEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SecurityDefinitions_SecurityEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SecurityDefinitions_SecurityEntry_DoNotUse& other);
  static const SecurityDefinitions_SecurityEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SecurityDefinitions_SecurityEntry_DoNotUse*>(&_SecurityDefinitions_SecurityEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.SecurityEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};
// -------------------------------------------------------------------

class AGONES_EXPORT SecurityDefinitions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions) */ {
 public:
  inline SecurityDefinitions() : SecurityDefinitions(nullptr) {}
  ~SecurityDefinitions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SecurityDefinitions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecurityDefinitions(const SecurityDefinitions& from);
  SecurityDefinitions(SecurityDefinitions&& from) noexcept
    : SecurityDefinitions() {
    *this = ::std::move(from);
  }

  inline SecurityDefinitions& operator=(const SecurityDefinitions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecurityDefinitions& operator=(SecurityDefinitions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecurityDefinitions& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecurityDefinitions* internal_default_instance() {
    return reinterpret_cast<const SecurityDefinitions*>(
               &_SecurityDefinitions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SecurityDefinitions& a, SecurityDefinitions& b) {
    a.Swap(&b);
  }
  inline void Swap(SecurityDefinitions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecurityDefinitions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecurityDefinitions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecurityDefinitions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SecurityDefinitions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SecurityDefinitions& from) {
    SecurityDefinitions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityDefinitions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions";
  }
  protected:
  explicit SecurityDefinitions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecurityFieldNumber = 1,
  };
  // map<string, .grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme> security = 1;
  int security_size() const;
  private:
  int _internal_security_size() const;

  public:
  void clear_security() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme >&
      _internal_security() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme >*
      _internal_mutable_security();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme >&
      security() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme >*
      mutable_security();
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SecurityDefinitions_SecurityEntry_DoNotUse,
        std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> security_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class SecurityScheme_ExtensionsEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SecurityScheme_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SecurityScheme_ExtensionsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SecurityScheme_ExtensionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SecurityScheme_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SecurityScheme_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SecurityScheme_ExtensionsEntry_DoNotUse& other);
  static const SecurityScheme_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SecurityScheme_ExtensionsEntry_DoNotUse*>(&_SecurityScheme_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};
// -------------------------------------------------------------------

class AGONES_EXPORT SecurityScheme final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme) */ {
 public:
  inline SecurityScheme() : SecurityScheme(nullptr) {}
  ~SecurityScheme() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SecurityScheme(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecurityScheme(const SecurityScheme& from);
  SecurityScheme(SecurityScheme&& from) noexcept
    : SecurityScheme() {
    *this = ::std::move(from);
  }

  inline SecurityScheme& operator=(const SecurityScheme& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecurityScheme& operator=(SecurityScheme&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecurityScheme& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecurityScheme* internal_default_instance() {
    return reinterpret_cast<const SecurityScheme*>(
               &_SecurityScheme_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SecurityScheme& a, SecurityScheme& b) {
    a.Swap(&b);
  }
  inline void Swap(SecurityScheme* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecurityScheme* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecurityScheme* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecurityScheme>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SecurityScheme& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SecurityScheme& from) {
    SecurityScheme::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityScheme* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme";
  }
  protected:
  explicit SecurityScheme(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  using Type = SecurityScheme_Type;
  static constexpr Type TYPE_INVALID = SecurityScheme_Type_TYPE_INVALID;
  static constexpr Type TYPE_BASIC = SecurityScheme_Type_TYPE_BASIC;
  static constexpr Type TYPE_API_KEY = SecurityScheme_Type_TYPE_API_KEY;
  static constexpr Type TYPE_OAUTH2 = SecurityScheme_Type_TYPE_OAUTH2;
  static inline bool Type_IsValid(int value) {
    return SecurityScheme_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = SecurityScheme_Type_Type_MIN;
  static constexpr Type Type_MAX = SecurityScheme_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = SecurityScheme_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_descriptor() {
    return SecurityScheme_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return SecurityScheme_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return SecurityScheme_Type_Parse(name, value);
  }

  using In = SecurityScheme_In;
  static constexpr In IN_INVALID = SecurityScheme_In_IN_INVALID;
  static constexpr In IN_QUERY = SecurityScheme_In_IN_QUERY;
  static constexpr In IN_HEADER = SecurityScheme_In_IN_HEADER;
  static inline bool In_IsValid(int value) {
    return SecurityScheme_In_IsValid(value);
  }
  static constexpr In In_MIN = SecurityScheme_In_In_MIN;
  static constexpr In In_MAX = SecurityScheme_In_In_MAX;
  static constexpr int In_ARRAYSIZE = SecurityScheme_In_In_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* In_descriptor() {
    return SecurityScheme_In_descriptor();
  }
  template <typename T>
  static inline const std::string& In_Name(T value) {
    return SecurityScheme_In_Name(value);
  }
  static inline bool In_Parse(absl::string_view name, In* value) {
    return SecurityScheme_In_Parse(name, value);
  }

  using Flow = SecurityScheme_Flow;
  static constexpr Flow FLOW_INVALID = SecurityScheme_Flow_FLOW_INVALID;
  static constexpr Flow FLOW_IMPLICIT = SecurityScheme_Flow_FLOW_IMPLICIT;
  static constexpr Flow FLOW_PASSWORD = SecurityScheme_Flow_FLOW_PASSWORD;
  static constexpr Flow FLOW_APPLICATION = SecurityScheme_Flow_FLOW_APPLICATION;
  static constexpr Flow FLOW_ACCESS_CODE = SecurityScheme_Flow_FLOW_ACCESS_CODE;
  static inline bool Flow_IsValid(int value) {
    return SecurityScheme_Flow_IsValid(value);
  }
  static constexpr Flow Flow_MIN = SecurityScheme_Flow_Flow_MIN;
  static constexpr Flow Flow_MAX = SecurityScheme_Flow_Flow_MAX;
  static constexpr int Flow_ARRAYSIZE = SecurityScheme_Flow_Flow_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Flow_descriptor() {
    return SecurityScheme_Flow_descriptor();
  }
  template <typename T>
  static inline const std::string& Flow_Name(T value) {
    return SecurityScheme_Flow_Name(value);
  }
  static inline bool Flow_Parse(absl::string_view name, Flow* value) {
    return SecurityScheme_Flow_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionsFieldNumber = 9,
    kDescriptionFieldNumber = 2,
    kNameFieldNumber = 3,
    kAuthorizationUrlFieldNumber = 6,
    kTokenUrlFieldNumber = 7,
    kScopesFieldNumber = 8,
    kTypeFieldNumber = 1,
    kInFieldNumber = 4,
    kFlowFieldNumber = 5,
  };
  // map<string, .google.protobuf.Value> extensions = 9;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;

  public:
  void clear_extensions() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
      mutable_extensions();
  // string description = 2;
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string name = 3;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string authorization_url = 6;
  void clear_authorization_url() ;
  const std::string& authorization_url() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_authorization_url(Arg_&& arg, Args_... args);
  std::string* mutable_authorization_url();
  PROTOBUF_NODISCARD std::string* release_authorization_url();
  void set_allocated_authorization_url(std::string* ptr);

  private:
  const std::string& _internal_authorization_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorization_url(
      const std::string& value);
  std::string* _internal_mutable_authorization_url();

  public:
  // string token_url = 7;
  void clear_token_url() ;
  const std::string& token_url() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token_url(Arg_&& arg, Args_... args);
  std::string* mutable_token_url();
  PROTOBUF_NODISCARD std::string* release_token_url();
  void set_allocated_token_url(std::string* ptr);

  private:
  const std::string& _internal_token_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_url(
      const std::string& value);
  std::string* _internal_mutable_token_url();

  public:
  // .grpc.gateway.protoc_gen_openapiv2.options.Scopes scopes = 8;
  bool has_scopes() const;
  void clear_scopes() ;
  const ::grpc::gateway::protoc_gen_openapiv2::options::Scopes& scopes() const;
  PROTOBUF_NODISCARD ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* release_scopes();
  ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* mutable_scopes();
  void set_allocated_scopes(::grpc::gateway::protoc_gen_openapiv2::options::Scopes* scopes);
  private:
  const ::grpc::gateway::protoc_gen_openapiv2::options::Scopes& _internal_scopes() const;
  ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* _internal_mutable_scopes();
  public:
  void unsafe_arena_set_allocated_scopes(
      ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* scopes);
  ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* unsafe_arena_release_scopes();
  // .grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Type type = 1;
  void clear_type() ;
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Type type() const;
  void set_type(::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Type value);

  private:
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Type _internal_type() const;
  void _internal_set_type(::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Type value);

  public:
  // .grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.In in = 4;
  void clear_in() ;
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_In in() const;
  void set_in(::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_In value);

  private:
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_In _internal_in() const;
  void _internal_set_in(::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_In value);

  public:
  // .grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Flow flow = 5;
  void clear_flow() ;
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Flow flow() const;
  void set_flow(::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Flow value);

  private:
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Flow _internal_flow() const;
  void _internal_set_flow(::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Flow value);

  public:
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SecurityScheme_ExtensionsEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Value,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorization_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_url_;
    ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* scopes_;
    int type_;
    int in_;
    int flow_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class AGONES_EXPORT SecurityRequirement_SecurityRequirementValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue) */ {
 public:
  inline SecurityRequirement_SecurityRequirementValue() : SecurityRequirement_SecurityRequirementValue(nullptr) {}
  ~SecurityRequirement_SecurityRequirementValue() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SecurityRequirement_SecurityRequirementValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecurityRequirement_SecurityRequirementValue(const SecurityRequirement_SecurityRequirementValue& from);
  SecurityRequirement_SecurityRequirementValue(SecurityRequirement_SecurityRequirementValue&& from) noexcept
    : SecurityRequirement_SecurityRequirementValue() {
    *this = ::std::move(from);
  }

  inline SecurityRequirement_SecurityRequirementValue& operator=(const SecurityRequirement_SecurityRequirementValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecurityRequirement_SecurityRequirementValue& operator=(SecurityRequirement_SecurityRequirementValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecurityRequirement_SecurityRequirementValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecurityRequirement_SecurityRequirementValue* internal_default_instance() {
    return reinterpret_cast<const SecurityRequirement_SecurityRequirementValue*>(
               &_SecurityRequirement_SecurityRequirementValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SecurityRequirement_SecurityRequirementValue& a, SecurityRequirement_SecurityRequirementValue& b) {
    a.Swap(&b);
  }
  inline void Swap(SecurityRequirement_SecurityRequirementValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecurityRequirement_SecurityRequirementValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecurityRequirement_SecurityRequirementValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecurityRequirement_SecurityRequirementValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SecurityRequirement_SecurityRequirementValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SecurityRequirement_SecurityRequirementValue& from) {
    SecurityRequirement_SecurityRequirementValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityRequirement_SecurityRequirementValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue";
  }
  protected:
  explicit SecurityRequirement_SecurityRequirementValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScopeFieldNumber = 1,
  };
  // repeated string scope = 1;
  int scope_size() const;
  private:
  int _internal_scope_size() const;

  public:
  void clear_scope() ;
  const std::string& scope(int index) const;
  std::string* mutable_scope(int index);
  void set_scope(int index, const std::string& value);
  void set_scope(int index, std::string&& value);
  void set_scope(int index, const char* value);
  void set_scope(int index, const char* value, std::size_t size);
  void set_scope(int index, absl::string_view value);
  std::string* add_scope();
  void add_scope(const std::string& value);
  void add_scope(std::string&& value);
  void add_scope(const char* value);
  void add_scope(const char* value, std::size_t size);
  void add_scope(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& scope() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_scope();

  private:
  const std::string& _internal_scope(int index) const;
  std::string* _internal_add_scope();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_scope() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_scope();

  public:
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> scope_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class SecurityRequirement_SecurityRequirementEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SecurityRequirement_SecurityRequirementEntry_DoNotUse, 
    std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement_SecurityRequirementValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SecurityRequirement_SecurityRequirementEntry_DoNotUse, 
    std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement_SecurityRequirementValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SecurityRequirement_SecurityRequirementEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SecurityRequirement_SecurityRequirementEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SecurityRequirement_SecurityRequirementEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SecurityRequirement_SecurityRequirementEntry_DoNotUse& other);
  static const SecurityRequirement_SecurityRequirementEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SecurityRequirement_SecurityRequirementEntry_DoNotUse*>(&_SecurityRequirement_SecurityRequirementEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};
// -------------------------------------------------------------------

class AGONES_EXPORT SecurityRequirement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement) */ {
 public:
  inline SecurityRequirement() : SecurityRequirement(nullptr) {}
  ~SecurityRequirement() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SecurityRequirement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SecurityRequirement(const SecurityRequirement& from);
  SecurityRequirement(SecurityRequirement&& from) noexcept
    : SecurityRequirement() {
    *this = ::std::move(from);
  }

  inline SecurityRequirement& operator=(const SecurityRequirement& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecurityRequirement& operator=(SecurityRequirement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecurityRequirement& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecurityRequirement* internal_default_instance() {
    return reinterpret_cast<const SecurityRequirement*>(
               &_SecurityRequirement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SecurityRequirement& a, SecurityRequirement& b) {
    a.Swap(&b);
  }
  inline void Swap(SecurityRequirement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecurityRequirement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecurityRequirement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecurityRequirement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SecurityRequirement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SecurityRequirement& from) {
    SecurityRequirement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityRequirement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement";
  }
  protected:
  explicit SecurityRequirement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SecurityRequirement_SecurityRequirementValue SecurityRequirementValue;

  // accessors -------------------------------------------------------

  enum : int {
    kSecurityRequirementFieldNumber = 1,
  };
  // map<string, .grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue> security_requirement = 1;
  int security_requirement_size() const;
  private:
  int _internal_security_requirement_size() const;

  public:
  void clear_security_requirement() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement_SecurityRequirementValue >&
      _internal_security_requirement() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement_SecurityRequirementValue >*
      _internal_mutable_security_requirement();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement_SecurityRequirementValue >&
      security_requirement() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement_SecurityRequirementValue >*
      mutable_security_requirement();
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SecurityRequirement_SecurityRequirementEntry_DoNotUse,
        std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement_SecurityRequirementValue,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> security_requirement_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};// -------------------------------------------------------------------

class Scopes_ScopeEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Scopes_ScopeEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Scopes_ScopeEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Scopes_ScopeEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Scopes_ScopeEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Scopes_ScopeEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Scopes_ScopeEntry_DoNotUse& other);
  static const Scopes_ScopeEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Scopes_ScopeEntry_DoNotUse*>(&_Scopes_ScopeEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "grpc.gateway.protoc_gen_openapiv2.options.Scopes.ScopeEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "grpc.gateway.protoc_gen_openapiv2.options.Scopes.ScopeEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};
// -------------------------------------------------------------------

class AGONES_EXPORT Scopes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.gateway.protoc_gen_openapiv2.options.Scopes) */ {
 public:
  inline Scopes() : Scopes(nullptr) {}
  ~Scopes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Scopes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Scopes(const Scopes& from);
  Scopes(Scopes&& from) noexcept
    : Scopes() {
    *this = ::std::move(from);
  }

  inline Scopes& operator=(const Scopes& from) {
    CopyFrom(from);
    return *this;
  }
  inline Scopes& operator=(Scopes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Scopes& default_instance() {
    return *internal_default_instance();
  }
  static inline const Scopes* internal_default_instance() {
    return reinterpret_cast<const Scopes*>(
               &_Scopes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Scopes& a, Scopes& b) {
    a.Swap(&b);
  }
  inline void Swap(Scopes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Scopes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Scopes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Scopes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Scopes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Scopes& from) {
    Scopes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scopes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "grpc.gateway.protoc_gen_openapiv2.options.Scopes";
  }
  protected:
  explicit Scopes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kScopeFieldNumber = 1,
  };
  // map<string, string> scope = 1;
  int scope_size() const;
  private:
  int _internal_scope_size() const;

  public:
  void clear_scope() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_scope() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_scope();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      scope() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_scope();
  // @@protoc_insertion_point(class_scope:grpc.gateway.protoc_gen_openapiv2.options.Scopes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Scopes_ScopeEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> scope_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Swagger

// string swagger = 1;
inline void Swagger::clear_swagger() {
  _impl_.swagger_.ClearToEmpty();
}
inline const std::string& Swagger::swagger() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Swagger.swagger)
  return _internal_swagger();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Swagger::set_swagger(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.swagger_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Swagger.swagger)
}
inline std::string* Swagger::mutable_swagger() {
  std::string* _s = _internal_mutable_swagger();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Swagger.swagger)
  return _s;
}
inline const std::string& Swagger::_internal_swagger() const {
  return _impl_.swagger_.Get();
}
inline void Swagger::_internal_set_swagger(const std::string& value) {
  ;


  _impl_.swagger_.Set(value, GetArenaForAllocation());
}
inline std::string* Swagger::_internal_mutable_swagger() {
  ;
  return _impl_.swagger_.Mutable( GetArenaForAllocation());
}
inline std::string* Swagger::release_swagger() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Swagger.swagger)
  return _impl_.swagger_.Release();
}
inline void Swagger::set_allocated_swagger(std::string* value) {
  _impl_.swagger_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.swagger_.IsDefault()) {
          _impl_.swagger_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Swagger.swagger)
}

// .grpc.gateway.protoc_gen_openapiv2.options.Info info = 2;
inline bool Swagger::has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline void Swagger::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::Info& Swagger::_internal_info() const {
  const ::grpc::gateway::protoc_gen_openapiv2::options::Info* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc::gateway::protoc_gen_openapiv2::options::Info&>(
      ::grpc::gateway::protoc_gen_openapiv2::options::_Info_default_instance_);
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::Info& Swagger::info() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Swagger.info)
  return _internal_info();
}
inline void Swagger::unsafe_arena_set_allocated_info(
    ::grpc::gateway::protoc_gen_openapiv2::options::Info* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Swagger.info)
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Info* Swagger::release_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::Info* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Info* Swagger::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Swagger.info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::Info* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Info* Swagger::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Info>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Info* Swagger::mutable_info() {
  ::grpc::gateway::protoc_gen_openapiv2::options::Info* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Swagger.info)
  return _msg;
}
inline void Swagger::set_allocated_info(::grpc::gateway::protoc_gen_openapiv2::options::Info* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Swagger.info)
}

// string host = 3;
inline void Swagger::clear_host() {
  _impl_.host_.ClearToEmpty();
}
inline const std::string& Swagger::host() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Swagger.host)
  return _internal_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Swagger::set_host(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.host_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Swagger.host)
}
inline std::string* Swagger::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Swagger.host)
  return _s;
}
inline const std::string& Swagger::_internal_host() const {
  return _impl_.host_.Get();
}
inline void Swagger::_internal_set_host(const std::string& value) {
  ;


  _impl_.host_.Set(value, GetArenaForAllocation());
}
inline std::string* Swagger::_internal_mutable_host() {
  ;
  return _impl_.host_.Mutable( GetArenaForAllocation());
}
inline std::string* Swagger::release_host() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Swagger.host)
  return _impl_.host_.Release();
}
inline void Swagger::set_allocated_host(std::string* value) {
  _impl_.host_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.host_.IsDefault()) {
          _impl_.host_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Swagger.host)
}

// string base_path = 4;
inline void Swagger::clear_base_path() {
  _impl_.base_path_.ClearToEmpty();
}
inline const std::string& Swagger::base_path() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Swagger.base_path)
  return _internal_base_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Swagger::set_base_path(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.base_path_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Swagger.base_path)
}
inline std::string* Swagger::mutable_base_path() {
  std::string* _s = _internal_mutable_base_path();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Swagger.base_path)
  return _s;
}
inline const std::string& Swagger::_internal_base_path() const {
  return _impl_.base_path_.Get();
}
inline void Swagger::_internal_set_base_path(const std::string& value) {
  ;


  _impl_.base_path_.Set(value, GetArenaForAllocation());
}
inline std::string* Swagger::_internal_mutable_base_path() {
  ;
  return _impl_.base_path_.Mutable( GetArenaForAllocation());
}
inline std::string* Swagger::release_base_path() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Swagger.base_path)
  return _impl_.base_path_.Release();
}
inline void Swagger::set_allocated_base_path(std::string* value) {
  _impl_.base_path_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.base_path_.IsDefault()) {
          _impl_.base_path_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Swagger.base_path)
}

// repeated .grpc.gateway.protoc_gen_openapiv2.options.Scheme schemes = 5;
inline int Swagger::_internal_schemes_size() const {
  return _impl_.schemes_.size();
}
inline int Swagger::schemes_size() const {
  return _internal_schemes_size();
}
inline void Swagger::clear_schemes() {
  _internal_mutable_schemes()->Clear();
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Scheme Swagger::schemes(int index) const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Swagger.schemes)
  return _internal_schemes(index);
}
inline void Swagger::set_schemes(int index, ::grpc::gateway::protoc_gen_openapiv2::options::Scheme value) {
  _internal_mutable_schemes()->Set(index, value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Swagger.schemes)
}
inline void Swagger::add_schemes(::grpc::gateway::protoc_gen_openapiv2::options::Scheme value) {
  _internal_add_schemes(value);
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.Swagger.schemes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& Swagger::schemes() const {
  // @@protoc_insertion_point(field_list:grpc.gateway.protoc_gen_openapiv2.options.Swagger.schemes)
  return _internal_schemes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Swagger::mutable_schemes() {
  // @@protoc_insertion_point(field_mutable_list:grpc.gateway.protoc_gen_openapiv2.options.Swagger.schemes)
  return _internal_mutable_schemes();
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Scheme Swagger::_internal_schemes(int index) const {
  return static_cast<::grpc::gateway::protoc_gen_openapiv2::options::Scheme>(_internal_schemes().Get(index));
}
inline void Swagger::_internal_add_schemes(::grpc::gateway::protoc_gen_openapiv2::options::Scheme value) {
  _internal_mutable_schemes()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& Swagger::_internal_schemes() const {
  return _impl_.schemes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Swagger::_internal_mutable_schemes() {
  return &_impl_.schemes_;
}

// repeated string consumes = 6;
inline int Swagger::_internal_consumes_size() const {
  return _impl_.consumes_.size();
}
inline int Swagger::consumes_size() const {
  return _internal_consumes_size();
}
inline void Swagger::clear_consumes() {
  _internal_mutable_consumes()->Clear();
}
inline std::string* Swagger::add_consumes() {
  std::string* _s = _internal_add_consumes();
  // @@protoc_insertion_point(field_add_mutable:grpc.gateway.protoc_gen_openapiv2.options.Swagger.consumes)
  return _s;
}
inline const std::string& Swagger::consumes(int index) const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Swagger.consumes)
  return _internal_consumes(index);
}
inline std::string* Swagger::mutable_consumes(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Swagger.consumes)
  return _internal_mutable_consumes()->Mutable(index);
}
inline void Swagger::set_consumes(int index, const std::string& value) {
  _internal_mutable_consumes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Swagger.consumes)
}
inline void Swagger::set_consumes(int index, std::string&& value) {
  _internal_mutable_consumes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Swagger.consumes)
}
inline void Swagger::set_consumes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_consumes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:grpc.gateway.protoc_gen_openapiv2.options.Swagger.consumes)
}
inline void Swagger::set_consumes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_consumes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:grpc.gateway.protoc_gen_openapiv2.options.Swagger.consumes)
}
inline void Swagger::set_consumes(int index, absl::string_view value) {
  _internal_mutable_consumes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:grpc.gateway.protoc_gen_openapiv2.options.Swagger.consumes)
}
inline void Swagger::add_consumes(const std::string& value) {
  _internal_mutable_consumes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.Swagger.consumes)
}
inline void Swagger::add_consumes(std::string&& value) {
  _internal_mutable_consumes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.Swagger.consumes)
}
inline void Swagger::add_consumes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_consumes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:grpc.gateway.protoc_gen_openapiv2.options.Swagger.consumes)
}
inline void Swagger::add_consumes(const char* value, std::size_t size) {
  _internal_mutable_consumes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:grpc.gateway.protoc_gen_openapiv2.options.Swagger.consumes)
}
inline void Swagger::add_consumes(absl::string_view value) {
  _internal_mutable_consumes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:grpc.gateway.protoc_gen_openapiv2.options.Swagger.consumes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Swagger::consumes() const {
  // @@protoc_insertion_point(field_list:grpc.gateway.protoc_gen_openapiv2.options.Swagger.consumes)
  return _internal_consumes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Swagger::mutable_consumes() {
  // @@protoc_insertion_point(field_mutable_list:grpc.gateway.protoc_gen_openapiv2.options.Swagger.consumes)
  return _internal_mutable_consumes();
}
inline const std::string& Swagger::_internal_consumes(int index) const {
  return _internal_consumes().Get(index);
}
inline std::string* Swagger::_internal_add_consumes() {
  return _internal_mutable_consumes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Swagger::_internal_consumes() const {
  return _impl_.consumes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Swagger::_internal_mutable_consumes() {
  return &_impl_.consumes_;
}

// repeated string produces = 7;
inline int Swagger::_internal_produces_size() const {
  return _impl_.produces_.size();
}
inline int Swagger::produces_size() const {
  return _internal_produces_size();
}
inline void Swagger::clear_produces() {
  _internal_mutable_produces()->Clear();
}
inline std::string* Swagger::add_produces() {
  std::string* _s = _internal_add_produces();
  // @@protoc_insertion_point(field_add_mutable:grpc.gateway.protoc_gen_openapiv2.options.Swagger.produces)
  return _s;
}
inline const std::string& Swagger::produces(int index) const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Swagger.produces)
  return _internal_produces(index);
}
inline std::string* Swagger::mutable_produces(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Swagger.produces)
  return _internal_mutable_produces()->Mutable(index);
}
inline void Swagger::set_produces(int index, const std::string& value) {
  _internal_mutable_produces()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Swagger.produces)
}
inline void Swagger::set_produces(int index, std::string&& value) {
  _internal_mutable_produces()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Swagger.produces)
}
inline void Swagger::set_produces(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_produces()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:grpc.gateway.protoc_gen_openapiv2.options.Swagger.produces)
}
inline void Swagger::set_produces(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_produces()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:grpc.gateway.protoc_gen_openapiv2.options.Swagger.produces)
}
inline void Swagger::set_produces(int index, absl::string_view value) {
  _internal_mutable_produces()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:grpc.gateway.protoc_gen_openapiv2.options.Swagger.produces)
}
inline void Swagger::add_produces(const std::string& value) {
  _internal_mutable_produces()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.Swagger.produces)
}
inline void Swagger::add_produces(std::string&& value) {
  _internal_mutable_produces()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.Swagger.produces)
}
inline void Swagger::add_produces(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_produces()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:grpc.gateway.protoc_gen_openapiv2.options.Swagger.produces)
}
inline void Swagger::add_produces(const char* value, std::size_t size) {
  _internal_mutable_produces()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:grpc.gateway.protoc_gen_openapiv2.options.Swagger.produces)
}
inline void Swagger::add_produces(absl::string_view value) {
  _internal_mutable_produces()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:grpc.gateway.protoc_gen_openapiv2.options.Swagger.produces)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Swagger::produces() const {
  // @@protoc_insertion_point(field_list:grpc.gateway.protoc_gen_openapiv2.options.Swagger.produces)
  return _internal_produces();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Swagger::mutable_produces() {
  // @@protoc_insertion_point(field_mutable_list:grpc.gateway.protoc_gen_openapiv2.options.Swagger.produces)
  return _internal_mutable_produces();
}
inline const std::string& Swagger::_internal_produces(int index) const {
  return _internal_produces().Get(index);
}
inline std::string* Swagger::_internal_add_produces() {
  return _internal_mutable_produces()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Swagger::_internal_produces() const {
  return _impl_.produces_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Swagger::_internal_mutable_produces() {
  return &_impl_.produces_;
}

// map<string, .grpc.gateway.protoc_gen_openapiv2.options.Response> responses = 10;
inline int Swagger::_internal_responses_size() const {
  return _impl_.responses_.size();
}
inline int Swagger::responses_size() const {
  return _internal_responses_size();
}
inline void Swagger::clear_responses() {
  _impl_.responses_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >&
Swagger::_internal_responses() const {
  return _impl_.responses_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >&
Swagger::responses() const {
  // @@protoc_insertion_point(field_map:grpc.gateway.protoc_gen_openapiv2.options.Swagger.responses)
  return _internal_responses();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >*
Swagger::_internal_mutable_responses() {
  return _impl_.responses_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >*
Swagger::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_map:grpc.gateway.protoc_gen_openapiv2.options.Swagger.responses)
  return _internal_mutable_responses();
}

// .grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions security_definitions = 11;
inline bool Swagger::has_security_definitions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.security_definitions_ != nullptr);
  return value;
}
inline void Swagger::clear_security_definitions() {
  if (_impl_.security_definitions_ != nullptr) _impl_.security_definitions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions& Swagger::_internal_security_definitions() const {
  const ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* p = _impl_.security_definitions_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions&>(
      ::grpc::gateway::protoc_gen_openapiv2::options::_SecurityDefinitions_default_instance_);
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions& Swagger::security_definitions() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Swagger.security_definitions)
  return _internal_security_definitions();
}
inline void Swagger::unsafe_arena_set_allocated_security_definitions(
    ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* security_definitions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.security_definitions_);
  }
  _impl_.security_definitions_ = security_definitions;
  if (security_definitions) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Swagger.security_definitions)
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* Swagger::release_security_definitions() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* temp = _impl_.security_definitions_;
  _impl_.security_definitions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* Swagger::unsafe_arena_release_security_definitions() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Swagger.security_definitions)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* temp = _impl_.security_definitions_;
  _impl_.security_definitions_ = nullptr;
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* Swagger::_internal_mutable_security_definitions() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.security_definitions_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions>(GetArenaForAllocation());
    _impl_.security_definitions_ = p;
  }
  return _impl_.security_definitions_;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* Swagger::mutable_security_definitions() {
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* _msg = _internal_mutable_security_definitions();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Swagger.security_definitions)
  return _msg;
}
inline void Swagger::set_allocated_security_definitions(::grpc::gateway::protoc_gen_openapiv2::options::SecurityDefinitions* security_definitions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.security_definitions_;
  }
  if (security_definitions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(security_definitions);
    if (message_arena != submessage_arena) {
      security_definitions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, security_definitions, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.security_definitions_ = security_definitions;
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Swagger.security_definitions)
}

// repeated .grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement security = 12;
inline int Swagger::_internal_security_size() const {
  return _impl_.security_.size();
}
inline int Swagger::security_size() const {
  return _internal_security_size();
}
inline void Swagger::clear_security() {
  _internal_mutable_security()->Clear();
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement* Swagger::mutable_security(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Swagger.security)
  return _internal_mutable_security()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement >*
Swagger::mutable_security() {
  // @@protoc_insertion_point(field_mutable_list:grpc.gateway.protoc_gen_openapiv2.options.Swagger.security)
  return _internal_mutable_security();
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement& Swagger::_internal_security(int index) const {
  return _internal_security().Get(index);
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement& Swagger::security(int index) const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Swagger.security)
  return _internal_security(index);
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement* Swagger::_internal_add_security() {
  return _internal_mutable_security()->Add();
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement* Swagger::add_security() {
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement* _add = _internal_add_security();
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.Swagger.security)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement >&
Swagger::security() const {
  // @@protoc_insertion_point(field_list:grpc.gateway.protoc_gen_openapiv2.options.Swagger.security)
  return _internal_security();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement>&
Swagger::_internal_security() const {
  return _impl_.security_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement>*
Swagger::_internal_mutable_security() {
  return &_impl_.security_;
}

// .grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 14;
inline bool Swagger::has_external_docs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_docs_ != nullptr);
  return value;
}
inline void Swagger::clear_external_docs() {
  if (_impl_.external_docs_ != nullptr) _impl_.external_docs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& Swagger::_internal_external_docs() const {
  const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* p = _impl_.external_docs_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation&>(
      ::grpc::gateway::protoc_gen_openapiv2::options::_ExternalDocumentation_default_instance_);
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& Swagger::external_docs() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Swagger.external_docs)
  return _internal_external_docs();
}
inline void Swagger::unsafe_arena_set_allocated_external_docs(
    ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_docs_);
  }
  _impl_.external_docs_ = external_docs;
  if (external_docs) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Swagger.external_docs)
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Swagger::release_external_docs() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Swagger::unsafe_arena_release_external_docs() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Swagger.external_docs)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Swagger::_internal_mutable_external_docs() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.external_docs_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation>(GetArenaForAllocation());
    _impl_.external_docs_ = p;
  }
  return _impl_.external_docs_;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Swagger::mutable_external_docs() {
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* _msg = _internal_mutable_external_docs();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Swagger.external_docs)
  return _msg;
}
inline void Swagger::set_allocated_external_docs(::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.external_docs_;
  }
  if (external_docs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_docs);
    if (message_arena != submessage_arena) {
      external_docs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_docs, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.external_docs_ = external_docs;
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Swagger.external_docs)
}

// map<string, .google.protobuf.Value> extensions = 15;
inline int Swagger::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int Swagger::extensions_size() const {
  return _internal_extensions_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
Swagger::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
Swagger::extensions() const {
  // @@protoc_insertion_point(field_map:grpc.gateway.protoc_gen_openapiv2.options.Swagger.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
Swagger::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
Swagger::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:grpc.gateway.protoc_gen_openapiv2.options.Swagger.extensions)
  return _internal_mutable_extensions();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Operation

// repeated string tags = 1;
inline int Operation::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int Operation::tags_size() const {
  return _internal_tags_size();
}
inline void Operation::clear_tags() {
  _internal_mutable_tags()->Clear();
}
inline std::string* Operation::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:grpc.gateway.protoc_gen_openapiv2.options.Operation.tags)
  return _s;
}
inline const std::string& Operation::tags(int index) const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Operation.tags)
  return _internal_tags(index);
}
inline std::string* Operation::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Operation.tags)
  return _internal_mutable_tags()->Mutable(index);
}
inline void Operation::set_tags(int index, const std::string& value) {
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Operation.tags)
}
inline void Operation::set_tags(int index, std::string&& value) {
  _internal_mutable_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Operation.tags)
}
inline void Operation::set_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:grpc.gateway.protoc_gen_openapiv2.options.Operation.tags)
}
inline void Operation::set_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:grpc.gateway.protoc_gen_openapiv2.options.Operation.tags)
}
inline void Operation::set_tags(int index, absl::string_view value) {
  _internal_mutable_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:grpc.gateway.protoc_gen_openapiv2.options.Operation.tags)
}
inline void Operation::add_tags(const std::string& value) {
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.Operation.tags)
}
inline void Operation::add_tags(std::string&& value) {
  _internal_mutable_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.Operation.tags)
}
inline void Operation::add_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:grpc.gateway.protoc_gen_openapiv2.options.Operation.tags)
}
inline void Operation::add_tags(const char* value, std::size_t size) {
  _internal_mutable_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:grpc.gateway.protoc_gen_openapiv2.options.Operation.tags)
}
inline void Operation::add_tags(absl::string_view value) {
  _internal_mutable_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:grpc.gateway.protoc_gen_openapiv2.options.Operation.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Operation::tags() const {
  // @@protoc_insertion_point(field_list:grpc.gateway.protoc_gen_openapiv2.options.Operation.tags)
  return _internal_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Operation::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:grpc.gateway.protoc_gen_openapiv2.options.Operation.tags)
  return _internal_mutable_tags();
}
inline const std::string& Operation::_internal_tags(int index) const {
  return _internal_tags().Get(index);
}
inline std::string* Operation::_internal_add_tags() {
  return _internal_mutable_tags()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Operation::_internal_tags() const {
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Operation::_internal_mutable_tags() {
  return &_impl_.tags_;
}

// string summary = 2;
inline void Operation::clear_summary() {
  _impl_.summary_.ClearToEmpty();
}
inline const std::string& Operation::summary() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Operation.summary)
  return _internal_summary();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Operation::set_summary(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.summary_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Operation.summary)
}
inline std::string* Operation::mutable_summary() {
  std::string* _s = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Operation.summary)
  return _s;
}
inline const std::string& Operation::_internal_summary() const {
  return _impl_.summary_.Get();
}
inline void Operation::_internal_set_summary(const std::string& value) {
  ;


  _impl_.summary_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_summary() {
  ;
  return _impl_.summary_.Mutable( GetArenaForAllocation());
}
inline std::string* Operation::release_summary() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Operation.summary)
  return _impl_.summary_.Release();
}
inline void Operation::set_allocated_summary(std::string* value) {
  _impl_.summary_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.summary_.IsDefault()) {
          _impl_.summary_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Operation.summary)
}

// string description = 3;
inline void Operation::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Operation::description() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Operation.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Operation::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Operation.description)
}
inline std::string* Operation::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Operation.description)
  return _s;
}
inline const std::string& Operation::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Operation::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* Operation::release_description() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Operation.description)
  return _impl_.description_.Release();
}
inline void Operation::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Operation.description)
}

// .grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 4;
inline bool Operation::has_external_docs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_docs_ != nullptr);
  return value;
}
inline void Operation::clear_external_docs() {
  if (_impl_.external_docs_ != nullptr) _impl_.external_docs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& Operation::_internal_external_docs() const {
  const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* p = _impl_.external_docs_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation&>(
      ::grpc::gateway::protoc_gen_openapiv2::options::_ExternalDocumentation_default_instance_);
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& Operation::external_docs() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Operation.external_docs)
  return _internal_external_docs();
}
inline void Operation::unsafe_arena_set_allocated_external_docs(
    ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_docs_);
  }
  _impl_.external_docs_ = external_docs;
  if (external_docs) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Operation.external_docs)
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Operation::release_external_docs() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Operation::unsafe_arena_release_external_docs() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Operation.external_docs)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Operation::_internal_mutable_external_docs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.external_docs_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation>(GetArenaForAllocation());
    _impl_.external_docs_ = p;
  }
  return _impl_.external_docs_;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Operation::mutable_external_docs() {
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* _msg = _internal_mutable_external_docs();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Operation.external_docs)
  return _msg;
}
inline void Operation::set_allocated_external_docs(::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.external_docs_;
  }
  if (external_docs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_docs);
    if (message_arena != submessage_arena) {
      external_docs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_docs, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.external_docs_ = external_docs;
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Operation.external_docs)
}

// string operation_id = 5;
inline void Operation::clear_operation_id() {
  _impl_.operation_id_.ClearToEmpty();
}
inline const std::string& Operation::operation_id() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Operation.operation_id)
  return _internal_operation_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Operation::set_operation_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operation_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Operation.operation_id)
}
inline std::string* Operation::mutable_operation_id() {
  std::string* _s = _internal_mutable_operation_id();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Operation.operation_id)
  return _s;
}
inline const std::string& Operation::_internal_operation_id() const {
  return _impl_.operation_id_.Get();
}
inline void Operation::_internal_set_operation_id(const std::string& value) {
  ;


  _impl_.operation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Operation::_internal_mutable_operation_id() {
  ;
  return _impl_.operation_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Operation::release_operation_id() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Operation.operation_id)
  return _impl_.operation_id_.Release();
}
inline void Operation::set_allocated_operation_id(std::string* value) {
  _impl_.operation_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_id_.IsDefault()) {
          _impl_.operation_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Operation.operation_id)
}

// repeated string consumes = 6;
inline int Operation::_internal_consumes_size() const {
  return _impl_.consumes_.size();
}
inline int Operation::consumes_size() const {
  return _internal_consumes_size();
}
inline void Operation::clear_consumes() {
  _internal_mutable_consumes()->Clear();
}
inline std::string* Operation::add_consumes() {
  std::string* _s = _internal_add_consumes();
  // @@protoc_insertion_point(field_add_mutable:grpc.gateway.protoc_gen_openapiv2.options.Operation.consumes)
  return _s;
}
inline const std::string& Operation::consumes(int index) const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Operation.consumes)
  return _internal_consumes(index);
}
inline std::string* Operation::mutable_consumes(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Operation.consumes)
  return _internal_mutable_consumes()->Mutable(index);
}
inline void Operation::set_consumes(int index, const std::string& value) {
  _internal_mutable_consumes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Operation.consumes)
}
inline void Operation::set_consumes(int index, std::string&& value) {
  _internal_mutable_consumes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Operation.consumes)
}
inline void Operation::set_consumes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_consumes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:grpc.gateway.protoc_gen_openapiv2.options.Operation.consumes)
}
inline void Operation::set_consumes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_consumes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:grpc.gateway.protoc_gen_openapiv2.options.Operation.consumes)
}
inline void Operation::set_consumes(int index, absl::string_view value) {
  _internal_mutable_consumes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:grpc.gateway.protoc_gen_openapiv2.options.Operation.consumes)
}
inline void Operation::add_consumes(const std::string& value) {
  _internal_mutable_consumes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.Operation.consumes)
}
inline void Operation::add_consumes(std::string&& value) {
  _internal_mutable_consumes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.Operation.consumes)
}
inline void Operation::add_consumes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_consumes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:grpc.gateway.protoc_gen_openapiv2.options.Operation.consumes)
}
inline void Operation::add_consumes(const char* value, std::size_t size) {
  _internal_mutable_consumes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:grpc.gateway.protoc_gen_openapiv2.options.Operation.consumes)
}
inline void Operation::add_consumes(absl::string_view value) {
  _internal_mutable_consumes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:grpc.gateway.protoc_gen_openapiv2.options.Operation.consumes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Operation::consumes() const {
  // @@protoc_insertion_point(field_list:grpc.gateway.protoc_gen_openapiv2.options.Operation.consumes)
  return _internal_consumes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Operation::mutable_consumes() {
  // @@protoc_insertion_point(field_mutable_list:grpc.gateway.protoc_gen_openapiv2.options.Operation.consumes)
  return _internal_mutable_consumes();
}
inline const std::string& Operation::_internal_consumes(int index) const {
  return _internal_consumes().Get(index);
}
inline std::string* Operation::_internal_add_consumes() {
  return _internal_mutable_consumes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Operation::_internal_consumes() const {
  return _impl_.consumes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Operation::_internal_mutable_consumes() {
  return &_impl_.consumes_;
}

// repeated string produces = 7;
inline int Operation::_internal_produces_size() const {
  return _impl_.produces_.size();
}
inline int Operation::produces_size() const {
  return _internal_produces_size();
}
inline void Operation::clear_produces() {
  _internal_mutable_produces()->Clear();
}
inline std::string* Operation::add_produces() {
  std::string* _s = _internal_add_produces();
  // @@protoc_insertion_point(field_add_mutable:grpc.gateway.protoc_gen_openapiv2.options.Operation.produces)
  return _s;
}
inline const std::string& Operation::produces(int index) const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Operation.produces)
  return _internal_produces(index);
}
inline std::string* Operation::mutable_produces(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Operation.produces)
  return _internal_mutable_produces()->Mutable(index);
}
inline void Operation::set_produces(int index, const std::string& value) {
  _internal_mutable_produces()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Operation.produces)
}
inline void Operation::set_produces(int index, std::string&& value) {
  _internal_mutable_produces()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Operation.produces)
}
inline void Operation::set_produces(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_produces()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:grpc.gateway.protoc_gen_openapiv2.options.Operation.produces)
}
inline void Operation::set_produces(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_produces()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:grpc.gateway.protoc_gen_openapiv2.options.Operation.produces)
}
inline void Operation::set_produces(int index, absl::string_view value) {
  _internal_mutable_produces()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:grpc.gateway.protoc_gen_openapiv2.options.Operation.produces)
}
inline void Operation::add_produces(const std::string& value) {
  _internal_mutable_produces()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.Operation.produces)
}
inline void Operation::add_produces(std::string&& value) {
  _internal_mutable_produces()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.Operation.produces)
}
inline void Operation::add_produces(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_produces()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:grpc.gateway.protoc_gen_openapiv2.options.Operation.produces)
}
inline void Operation::add_produces(const char* value, std::size_t size) {
  _internal_mutable_produces()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:grpc.gateway.protoc_gen_openapiv2.options.Operation.produces)
}
inline void Operation::add_produces(absl::string_view value) {
  _internal_mutable_produces()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:grpc.gateway.protoc_gen_openapiv2.options.Operation.produces)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Operation::produces() const {
  // @@protoc_insertion_point(field_list:grpc.gateway.protoc_gen_openapiv2.options.Operation.produces)
  return _internal_produces();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Operation::mutable_produces() {
  // @@protoc_insertion_point(field_mutable_list:grpc.gateway.protoc_gen_openapiv2.options.Operation.produces)
  return _internal_mutable_produces();
}
inline const std::string& Operation::_internal_produces(int index) const {
  return _internal_produces().Get(index);
}
inline std::string* Operation::_internal_add_produces() {
  return _internal_mutable_produces()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Operation::_internal_produces() const {
  return _impl_.produces_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Operation::_internal_mutable_produces() {
  return &_impl_.produces_;
}

// map<string, .grpc.gateway.protoc_gen_openapiv2.options.Response> responses = 9;
inline int Operation::_internal_responses_size() const {
  return _impl_.responses_.size();
}
inline int Operation::responses_size() const {
  return _internal_responses_size();
}
inline void Operation::clear_responses() {
  _impl_.responses_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >&
Operation::_internal_responses() const {
  return _impl_.responses_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >&
Operation::responses() const {
  // @@protoc_insertion_point(field_map:grpc.gateway.protoc_gen_openapiv2.options.Operation.responses)
  return _internal_responses();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >*
Operation::_internal_mutable_responses() {
  return _impl_.responses_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Response >*
Operation::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_map:grpc.gateway.protoc_gen_openapiv2.options.Operation.responses)
  return _internal_mutable_responses();
}

// repeated .grpc.gateway.protoc_gen_openapiv2.options.Scheme schemes = 10;
inline int Operation::_internal_schemes_size() const {
  return _impl_.schemes_.size();
}
inline int Operation::schemes_size() const {
  return _internal_schemes_size();
}
inline void Operation::clear_schemes() {
  _internal_mutable_schemes()->Clear();
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Scheme Operation::schemes(int index) const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Operation.schemes)
  return _internal_schemes(index);
}
inline void Operation::set_schemes(int index, ::grpc::gateway::protoc_gen_openapiv2::options::Scheme value) {
  _internal_mutable_schemes()->Set(index, value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Operation.schemes)
}
inline void Operation::add_schemes(::grpc::gateway::protoc_gen_openapiv2::options::Scheme value) {
  _internal_add_schemes(value);
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.Operation.schemes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& Operation::schemes() const {
  // @@protoc_insertion_point(field_list:grpc.gateway.protoc_gen_openapiv2.options.Operation.schemes)
  return _internal_schemes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Operation::mutable_schemes() {
  // @@protoc_insertion_point(field_mutable_list:grpc.gateway.protoc_gen_openapiv2.options.Operation.schemes)
  return _internal_mutable_schemes();
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Scheme Operation::_internal_schemes(int index) const {
  return static_cast<::grpc::gateway::protoc_gen_openapiv2::options::Scheme>(_internal_schemes().Get(index));
}
inline void Operation::_internal_add_schemes(::grpc::gateway::protoc_gen_openapiv2::options::Scheme value) {
  _internal_mutable_schemes()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& Operation::_internal_schemes() const {
  return _impl_.schemes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Operation::_internal_mutable_schemes() {
  return &_impl_.schemes_;
}

// bool deprecated = 11;
inline void Operation::clear_deprecated() {
  _impl_.deprecated_ = false;
}
inline bool Operation::deprecated() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Operation.deprecated)
  return _internal_deprecated();
}
inline void Operation::set_deprecated(bool value) {
  _internal_set_deprecated(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Operation.deprecated)
}
inline bool Operation::_internal_deprecated() const {
  return _impl_.deprecated_;
}
inline void Operation::_internal_set_deprecated(bool value) {
  ;
  _impl_.deprecated_ = value;
}

// repeated .grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement security = 12;
inline int Operation::_internal_security_size() const {
  return _impl_.security_.size();
}
inline int Operation::security_size() const {
  return _internal_security_size();
}
inline void Operation::clear_security() {
  _internal_mutable_security()->Clear();
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement* Operation::mutable_security(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Operation.security)
  return _internal_mutable_security()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement >*
Operation::mutable_security() {
  // @@protoc_insertion_point(field_mutable_list:grpc.gateway.protoc_gen_openapiv2.options.Operation.security)
  return _internal_mutable_security();
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement& Operation::_internal_security(int index) const {
  return _internal_security().Get(index);
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement& Operation::security(int index) const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Operation.security)
  return _internal_security(index);
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement* Operation::_internal_add_security() {
  return _internal_mutable_security()->Add();
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement* Operation::add_security() {
  ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement* _add = _internal_add_security();
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.Operation.security)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement >&
Operation::security() const {
  // @@protoc_insertion_point(field_list:grpc.gateway.protoc_gen_openapiv2.options.Operation.security)
  return _internal_security();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement>&
Operation::_internal_security() const {
  return _impl_.security_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement>*
Operation::_internal_mutable_security() {
  return &_impl_.security_;
}

// map<string, .google.protobuf.Value> extensions = 13;
inline int Operation::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int Operation::extensions_size() const {
  return _internal_extensions_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
Operation::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
Operation::extensions() const {
  // @@protoc_insertion_point(field_map:grpc.gateway.protoc_gen_openapiv2.options.Operation.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
Operation::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
Operation::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:grpc.gateway.protoc_gen_openapiv2.options.Operation.extensions)
  return _internal_mutable_extensions();
}

// -------------------------------------------------------------------

// Header

// string description = 1;
inline void Header::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Header::description() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Header.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Header.description)
}
inline std::string* Header::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Header.description)
  return _s;
}
inline const std::string& Header::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Header::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* Header::release_description() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Header.description)
  return _impl_.description_.Release();
}
inline void Header::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Header.description)
}

// string type = 2;
inline void Header::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Header::type() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Header.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header::set_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Header.type)
}
inline std::string* Header::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Header.type)
  return _s;
}
inline const std::string& Header::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Header::_internal_set_type(const std::string& value) {
  ;


  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_type() {
  ;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* Header::release_type() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Header.type)
  return _impl_.type_.Release();
}
inline void Header::set_allocated_type(std::string* value) {
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Header.type)
}

// string format = 3;
inline void Header::clear_format() {
  _impl_.format_.ClearToEmpty();
}
inline const std::string& Header::format() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Header.format)
  return _internal_format();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header::set_format(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.format_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Header.format)
}
inline std::string* Header::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Header.format)
  return _s;
}
inline const std::string& Header::_internal_format() const {
  return _impl_.format_.Get();
}
inline void Header::_internal_set_format(const std::string& value) {
  ;


  _impl_.format_.Set(value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_format() {
  ;
  return _impl_.format_.Mutable( GetArenaForAllocation());
}
inline std::string* Header::release_format() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Header.format)
  return _impl_.format_.Release();
}
inline void Header::set_allocated_format(std::string* value) {
  _impl_.format_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.format_.IsDefault()) {
          _impl_.format_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Header.format)
}

// string default = 6;
inline void Header::clear_default_() {
  _impl_.default__.ClearToEmpty();
}
inline const std::string& Header::default_() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Header.default)
  return _internal_default_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header::set_default_(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.default__.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Header.default)
}
inline std::string* Header::mutable_default_() {
  std::string* _s = _internal_mutable_default_();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Header.default)
  return _s;
}
inline const std::string& Header::_internal_default_() const {
  return _impl_.default__.Get();
}
inline void Header::_internal_set_default_(const std::string& value) {
  ;


  _impl_.default__.Set(value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_default_() {
  ;
  return _impl_.default__.Mutable( GetArenaForAllocation());
}
inline std::string* Header::release_default_() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Header.default)
  return _impl_.default__.Release();
}
inline void Header::set_allocated_default_(std::string* value) {
  _impl_.default__.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default__.IsDefault()) {
          _impl_.default__.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Header.default)
}

// string pattern = 13;
inline void Header::clear_pattern() {
  _impl_.pattern_.ClearToEmpty();
}
inline const std::string& Header::pattern() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Header.pattern)
  return _internal_pattern();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Header::set_pattern(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Header.pattern)
}
inline std::string* Header::mutable_pattern() {
  std::string* _s = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Header.pattern)
  return _s;
}
inline const std::string& Header::_internal_pattern() const {
  return _impl_.pattern_.Get();
}
inline void Header::_internal_set_pattern(const std::string& value) {
  ;


  _impl_.pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* Header::_internal_mutable_pattern() {
  ;
  return _impl_.pattern_.Mutable( GetArenaForAllocation());
}
inline std::string* Header::release_pattern() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Header.pattern)
  return _impl_.pattern_.Release();
}
inline void Header::set_allocated_pattern(std::string* value) {
  _impl_.pattern_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pattern_.IsDefault()) {
          _impl_.pattern_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Header.pattern)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Response

// string description = 1;
inline void Response::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Response::description() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Response.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Response::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Response.description)
}
inline std::string* Response::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Response.description)
  return _s;
}
inline const std::string& Response::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Response::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Response::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* Response::release_description() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Response.description)
  return _impl_.description_.Release();
}
inline void Response::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Response.description)
}

// .grpc.gateway.protoc_gen_openapiv2.options.Schema schema = 2;
inline bool Response::has_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schema_ != nullptr);
  return value;
}
inline void Response::clear_schema() {
  if (_impl_.schema_ != nullptr) _impl_.schema_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::Schema& Response::_internal_schema() const {
  const ::grpc::gateway::protoc_gen_openapiv2::options::Schema* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc::gateway::protoc_gen_openapiv2::options::Schema&>(
      ::grpc::gateway::protoc_gen_openapiv2::options::_Schema_default_instance_);
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::Schema& Response::schema() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Response.schema)
  return _internal_schema();
}
inline void Response::unsafe_arena_set_allocated_schema(
    ::grpc::gateway::protoc_gen_openapiv2::options::Schema* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = schema;
  if (schema) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Response.schema)
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Schema* Response::release_schema() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::Schema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Schema* Response::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Response.schema)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::Schema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Schema* Response::_internal_mutable_schema() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Schema>(GetArenaForAllocation());
    _impl_.schema_ = p;
  }
  return _impl_.schema_;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Schema* Response::mutable_schema() {
  ::grpc::gateway::protoc_gen_openapiv2::options::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Response.schema)
  return _msg;
}
inline void Response::set_allocated_schema(::grpc::gateway::protoc_gen_openapiv2::options::Schema* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Response.schema)
}

// map<string, .grpc.gateway.protoc_gen_openapiv2.options.Header> headers = 3;
inline int Response::_internal_headers_size() const {
  return _impl_.headers_.size();
}
inline int Response::headers_size() const {
  return _internal_headers_size();
}
inline void Response::clear_headers() {
  _impl_.headers_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Header >&
Response::_internal_headers() const {
  return _impl_.headers_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Header >&
Response::headers() const {
  // @@protoc_insertion_point(field_map:grpc.gateway.protoc_gen_openapiv2.options.Response.headers)
  return _internal_headers();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Header >*
Response::_internal_mutable_headers() {
  return _impl_.headers_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::Header >*
Response::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_map:grpc.gateway.protoc_gen_openapiv2.options.Response.headers)
  return _internal_mutable_headers();
}

// map<string, string> examples = 4;
inline int Response::_internal_examples_size() const {
  return _impl_.examples_.size();
}
inline int Response::examples_size() const {
  return _internal_examples_size();
}
inline void Response::clear_examples() {
  _impl_.examples_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Response::_internal_examples() const {
  return _impl_.examples_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Response::examples() const {
  // @@protoc_insertion_point(field_map:grpc.gateway.protoc_gen_openapiv2.options.Response.examples)
  return _internal_examples();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Response::_internal_mutable_examples() {
  return _impl_.examples_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Response::mutable_examples() {
  // @@protoc_insertion_point(field_mutable_map:grpc.gateway.protoc_gen_openapiv2.options.Response.examples)
  return _internal_mutable_examples();
}

// map<string, .google.protobuf.Value> extensions = 5;
inline int Response::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int Response::extensions_size() const {
  return _internal_extensions_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
Response::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
Response::extensions() const {
  // @@protoc_insertion_point(field_map:grpc.gateway.protoc_gen_openapiv2.options.Response.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
Response::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
Response::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:grpc.gateway.protoc_gen_openapiv2.options.Response.extensions)
  return _internal_mutable_extensions();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Info

// string title = 1;
inline void Info::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& Info::title() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Info.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Info::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Info.title)
}
inline std::string* Info::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Info.title)
  return _s;
}
inline const std::string& Info::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Info::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* Info::release_title() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Info.title)
  return _impl_.title_.Release();
}
inline void Info::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Info.title)
}

// string description = 2;
inline void Info::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Info::description() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Info.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Info::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Info.description)
}
inline std::string* Info::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Info.description)
  return _s;
}
inline const std::string& Info::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Info::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* Info::release_description() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Info.description)
  return _impl_.description_.Release();
}
inline void Info::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Info.description)
}

// string terms_of_service = 3;
inline void Info::clear_terms_of_service() {
  _impl_.terms_of_service_.ClearToEmpty();
}
inline const std::string& Info::terms_of_service() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Info.terms_of_service)
  return _internal_terms_of_service();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Info::set_terms_of_service(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.terms_of_service_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Info.terms_of_service)
}
inline std::string* Info::mutable_terms_of_service() {
  std::string* _s = _internal_mutable_terms_of_service();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Info.terms_of_service)
  return _s;
}
inline const std::string& Info::_internal_terms_of_service() const {
  return _impl_.terms_of_service_.Get();
}
inline void Info::_internal_set_terms_of_service(const std::string& value) {
  ;


  _impl_.terms_of_service_.Set(value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_terms_of_service() {
  ;
  return _impl_.terms_of_service_.Mutable( GetArenaForAllocation());
}
inline std::string* Info::release_terms_of_service() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Info.terms_of_service)
  return _impl_.terms_of_service_.Release();
}
inline void Info::set_allocated_terms_of_service(std::string* value) {
  _impl_.terms_of_service_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.terms_of_service_.IsDefault()) {
          _impl_.terms_of_service_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Info.terms_of_service)
}

// .grpc.gateway.protoc_gen_openapiv2.options.Contact contact = 4;
inline bool Info::has_contact() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contact_ != nullptr);
  return value;
}
inline void Info::clear_contact() {
  if (_impl_.contact_ != nullptr) _impl_.contact_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::Contact& Info::_internal_contact() const {
  const ::grpc::gateway::protoc_gen_openapiv2::options::Contact* p = _impl_.contact_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc::gateway::protoc_gen_openapiv2::options::Contact&>(
      ::grpc::gateway::protoc_gen_openapiv2::options::_Contact_default_instance_);
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::Contact& Info::contact() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Info.contact)
  return _internal_contact();
}
inline void Info::unsafe_arena_set_allocated_contact(
    ::grpc::gateway::protoc_gen_openapiv2::options::Contact* contact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contact_);
  }
  _impl_.contact_ = contact;
  if (contact) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Info.contact)
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Contact* Info::release_contact() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Contact* Info::unsafe_arena_release_contact() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Info.contact)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::Contact* temp = _impl_.contact_;
  _impl_.contact_ = nullptr;
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Contact* Info::_internal_mutable_contact() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.contact_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Contact>(GetArenaForAllocation());
    _impl_.contact_ = p;
  }
  return _impl_.contact_;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Contact* Info::mutable_contact() {
  ::grpc::gateway::protoc_gen_openapiv2::options::Contact* _msg = _internal_mutable_contact();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Info.contact)
  return _msg;
}
inline void Info::set_allocated_contact(::grpc::gateway::protoc_gen_openapiv2::options::Contact* contact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contact_;
  }
  if (contact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contact);
    if (message_arena != submessage_arena) {
      contact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contact, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.contact_ = contact;
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Info.contact)
}

// .grpc.gateway.protoc_gen_openapiv2.options.License license = 5;
inline bool Info::has_license() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.license_ != nullptr);
  return value;
}
inline void Info::clear_license() {
  if (_impl_.license_ != nullptr) _impl_.license_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::License& Info::_internal_license() const {
  const ::grpc::gateway::protoc_gen_openapiv2::options::License* p = _impl_.license_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc::gateway::protoc_gen_openapiv2::options::License&>(
      ::grpc::gateway::protoc_gen_openapiv2::options::_License_default_instance_);
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::License& Info::license() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Info.license)
  return _internal_license();
}
inline void Info::unsafe_arena_set_allocated_license(
    ::grpc::gateway::protoc_gen_openapiv2::options::License* license) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.license_);
  }
  _impl_.license_ = license;
  if (license) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Info.license)
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::License* Info::release_license() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::grpc::gateway::protoc_gen_openapiv2::options::License* temp = _impl_.license_;
  _impl_.license_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::License* Info::unsafe_arena_release_license() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Info.license)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::grpc::gateway::protoc_gen_openapiv2::options::License* temp = _impl_.license_;
  _impl_.license_ = nullptr;
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::License* Info::_internal_mutable_license() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.license_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::License>(GetArenaForAllocation());
    _impl_.license_ = p;
  }
  return _impl_.license_;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::License* Info::mutable_license() {
  ::grpc::gateway::protoc_gen_openapiv2::options::License* _msg = _internal_mutable_license();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Info.license)
  return _msg;
}
inline void Info::set_allocated_license(::grpc::gateway::protoc_gen_openapiv2::options::License* license) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.license_;
  }
  if (license) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(license);
    if (message_arena != submessage_arena) {
      license = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, license, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.license_ = license;
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Info.license)
}

// string version = 6;
inline void Info::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Info::version() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Info.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Info::set_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Info.version)
}
inline std::string* Info::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Info.version)
  return _s;
}
inline const std::string& Info::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Info::_internal_set_version(const std::string& value) {
  ;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_version() {
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* Info::release_version() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Info.version)
  return _impl_.version_.Release();
}
inline void Info::set_allocated_version(std::string* value) {
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Info.version)
}

// map<string, .google.protobuf.Value> extensions = 7;
inline int Info::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int Info::extensions_size() const {
  return _internal_extensions_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
Info::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
Info::extensions() const {
  // @@protoc_insertion_point(field_map:grpc.gateway.protoc_gen_openapiv2.options.Info.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
Info::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
Info::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:grpc.gateway.protoc_gen_openapiv2.options.Info.extensions)
  return _internal_mutable_extensions();
}

// -------------------------------------------------------------------

// Contact

// string name = 1;
inline void Contact::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Contact::name() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Contact.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contact::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Contact.name)
}
inline std::string* Contact::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Contact.name)
  return _s;
}
inline const std::string& Contact::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Contact::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Contact::release_name() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Contact.name)
  return _impl_.name_.Release();
}
inline void Contact::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Contact.name)
}

// string url = 2;
inline void Contact::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& Contact::url() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Contact.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contact::set_url(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Contact.url)
}
inline std::string* Contact::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Contact.url)
  return _s;
}
inline const std::string& Contact::_internal_url() const {
  return _impl_.url_.Get();
}
inline void Contact::_internal_set_url(const std::string& value) {
  ;


  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact::_internal_mutable_url() {
  ;
  return _impl_.url_.Mutable( GetArenaForAllocation());
}
inline std::string* Contact::release_url() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Contact.url)
  return _impl_.url_.Release();
}
inline void Contact::set_allocated_url(std::string* value) {
  _impl_.url_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.url_.IsDefault()) {
          _impl_.url_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Contact.url)
}

// string email = 3;
inline void Contact::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& Contact::email() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Contact.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contact::set_email(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Contact.email)
}
inline std::string* Contact::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Contact.email)
  return _s;
}
inline const std::string& Contact::_internal_email() const {
  return _impl_.email_.Get();
}
inline void Contact::_internal_set_email(const std::string& value) {
  ;


  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* Contact::_internal_mutable_email() {
  ;
  return _impl_.email_.Mutable( GetArenaForAllocation());
}
inline std::string* Contact::release_email() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Contact.email)
  return _impl_.email_.Release();
}
inline void Contact::set_allocated_email(std::string* value) {
  _impl_.email_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Contact.email)
}

// -------------------------------------------------------------------

// License

// string name = 1;
inline void License::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& License::name() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.License.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void License::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.License.name)
}
inline std::string* License::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.License.name)
  return _s;
}
inline const std::string& License::_internal_name() const {
  return _impl_.name_.Get();
}
inline void License::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* License::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* License::release_name() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.License.name)
  return _impl_.name_.Release();
}
inline void License::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.License.name)
}

// string url = 2;
inline void License::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& License::url() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.License.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void License::set_url(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.License.url)
}
inline std::string* License::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.License.url)
  return _s;
}
inline const std::string& License::_internal_url() const {
  return _impl_.url_.Get();
}
inline void License::_internal_set_url(const std::string& value) {
  ;


  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* License::_internal_mutable_url() {
  ;
  return _impl_.url_.Mutable( GetArenaForAllocation());
}
inline std::string* License::release_url() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.License.url)
  return _impl_.url_.Release();
}
inline void License::set_allocated_url(std::string* value) {
  _impl_.url_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.url_.IsDefault()) {
          _impl_.url_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.License.url)
}

// -------------------------------------------------------------------

// ExternalDocumentation

// string description = 1;
inline void ExternalDocumentation::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ExternalDocumentation::description() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExternalDocumentation::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation.description)
}
inline std::string* ExternalDocumentation::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation.description)
  return _s;
}
inline const std::string& ExternalDocumentation::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ExternalDocumentation::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ExternalDocumentation::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* ExternalDocumentation::release_description() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation.description)
  return _impl_.description_.Release();
}
inline void ExternalDocumentation::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation.description)
}

// string url = 2;
inline void ExternalDocumentation::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& ExternalDocumentation::url() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExternalDocumentation::set_url(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation.url)
}
inline std::string* ExternalDocumentation::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation.url)
  return _s;
}
inline const std::string& ExternalDocumentation::_internal_url() const {
  return _impl_.url_.Get();
}
inline void ExternalDocumentation::_internal_set_url(const std::string& value) {
  ;


  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ExternalDocumentation::_internal_mutable_url() {
  ;
  return _impl_.url_.Mutable( GetArenaForAllocation());
}
inline std::string* ExternalDocumentation::release_url() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation.url)
  return _impl_.url_.Release();
}
inline void ExternalDocumentation::set_allocated_url(std::string* value) {
  _impl_.url_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.url_.IsDefault()) {
          _impl_.url_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation.url)
}

// -------------------------------------------------------------------

// Schema

// .grpc.gateway.protoc_gen_openapiv2.options.JSONSchema json_schema = 1;
inline bool Schema::has_json_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.json_schema_ != nullptr);
  return value;
}
inline void Schema::clear_json_schema() {
  if (_impl_.json_schema_ != nullptr) _impl_.json_schema_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema& Schema::_internal_json_schema() const {
  const ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* p = _impl_.json_schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema&>(
      ::grpc::gateway::protoc_gen_openapiv2::options::_JSONSchema_default_instance_);
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema& Schema::json_schema() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Schema.json_schema)
  return _internal_json_schema();
}
inline void Schema::unsafe_arena_set_allocated_json_schema(
    ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* json_schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.json_schema_);
  }
  _impl_.json_schema_ = json_schema;
  if (json_schema) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Schema.json_schema)
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* Schema::release_json_schema() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* temp = _impl_.json_schema_;
  _impl_.json_schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* Schema::unsafe_arena_release_json_schema() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Schema.json_schema)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* temp = _impl_.json_schema_;
  _impl_.json_schema_ = nullptr;
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* Schema::_internal_mutable_json_schema() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.json_schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema>(GetArenaForAllocation());
    _impl_.json_schema_ = p;
  }
  return _impl_.json_schema_;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* Schema::mutable_json_schema() {
  ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* _msg = _internal_mutable_json_schema();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Schema.json_schema)
  return _msg;
}
inline void Schema::set_allocated_json_schema(::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema* json_schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.json_schema_;
  }
  if (json_schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(json_schema);
    if (message_arena != submessage_arena) {
      json_schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, json_schema, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.json_schema_ = json_schema;
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Schema.json_schema)
}

// string discriminator = 2;
inline void Schema::clear_discriminator() {
  _impl_.discriminator_.ClearToEmpty();
}
inline const std::string& Schema::discriminator() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Schema.discriminator)
  return _internal_discriminator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Schema::set_discriminator(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.discriminator_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Schema.discriminator)
}
inline std::string* Schema::mutable_discriminator() {
  std::string* _s = _internal_mutable_discriminator();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Schema.discriminator)
  return _s;
}
inline const std::string& Schema::_internal_discriminator() const {
  return _impl_.discriminator_.Get();
}
inline void Schema::_internal_set_discriminator(const std::string& value) {
  ;


  _impl_.discriminator_.Set(value, GetArenaForAllocation());
}
inline std::string* Schema::_internal_mutable_discriminator() {
  ;
  return _impl_.discriminator_.Mutable( GetArenaForAllocation());
}
inline std::string* Schema::release_discriminator() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Schema.discriminator)
  return _impl_.discriminator_.Release();
}
inline void Schema::set_allocated_discriminator(std::string* value) {
  _impl_.discriminator_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.discriminator_.IsDefault()) {
          _impl_.discriminator_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Schema.discriminator)
}

// bool read_only = 3;
inline void Schema::clear_read_only() {
  _impl_.read_only_ = false;
}
inline bool Schema::read_only() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Schema.read_only)
  return _internal_read_only();
}
inline void Schema::set_read_only(bool value) {
  _internal_set_read_only(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Schema.read_only)
}
inline bool Schema::_internal_read_only() const {
  return _impl_.read_only_;
}
inline void Schema::_internal_set_read_only(bool value) {
  ;
  _impl_.read_only_ = value;
}

// .grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 5;
inline bool Schema::has_external_docs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_docs_ != nullptr);
  return value;
}
inline void Schema::clear_external_docs() {
  if (_impl_.external_docs_ != nullptr) _impl_.external_docs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& Schema::_internal_external_docs() const {
  const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* p = _impl_.external_docs_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation&>(
      ::grpc::gateway::protoc_gen_openapiv2::options::_ExternalDocumentation_default_instance_);
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& Schema::external_docs() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Schema.external_docs)
  return _internal_external_docs();
}
inline void Schema::unsafe_arena_set_allocated_external_docs(
    ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_docs_);
  }
  _impl_.external_docs_ = external_docs;
  if (external_docs) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Schema.external_docs)
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Schema::release_external_docs() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Schema::unsafe_arena_release_external_docs() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Schema.external_docs)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Schema::_internal_mutable_external_docs() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.external_docs_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation>(GetArenaForAllocation());
    _impl_.external_docs_ = p;
  }
  return _impl_.external_docs_;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Schema::mutable_external_docs() {
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* _msg = _internal_mutable_external_docs();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Schema.external_docs)
  return _msg;
}
inline void Schema::set_allocated_external_docs(::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.external_docs_;
  }
  if (external_docs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_docs);
    if (message_arena != submessage_arena) {
      external_docs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_docs, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.external_docs_ = external_docs;
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Schema.external_docs)
}

// string example = 6;
inline void Schema::clear_example() {
  _impl_.example_.ClearToEmpty();
}
inline const std::string& Schema::example() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Schema.example)
  return _internal_example();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Schema::set_example(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.example_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Schema.example)
}
inline std::string* Schema::mutable_example() {
  std::string* _s = _internal_mutable_example();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Schema.example)
  return _s;
}
inline const std::string& Schema::_internal_example() const {
  return _impl_.example_.Get();
}
inline void Schema::_internal_set_example(const std::string& value) {
  ;


  _impl_.example_.Set(value, GetArenaForAllocation());
}
inline std::string* Schema::_internal_mutable_example() {
  ;
  return _impl_.example_.Mutable( GetArenaForAllocation());
}
inline std::string* Schema::release_example() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Schema.example)
  return _impl_.example_.Release();
}
inline void Schema::set_allocated_example(std::string* value) {
  _impl_.example_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.example_.IsDefault()) {
          _impl_.example_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Schema.example)
}

// -------------------------------------------------------------------

// JSONSchema_FieldConfiguration

// string path_param_name = 47;
inline void JSONSchema_FieldConfiguration::clear_path_param_name() {
  _impl_.path_param_name_.ClearToEmpty();
}
inline const std::string& JSONSchema_FieldConfiguration::path_param_name() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration.path_param_name)
  return _internal_path_param_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JSONSchema_FieldConfiguration::set_path_param_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.path_param_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration.path_param_name)
}
inline std::string* JSONSchema_FieldConfiguration::mutable_path_param_name() {
  std::string* _s = _internal_mutable_path_param_name();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration.path_param_name)
  return _s;
}
inline const std::string& JSONSchema_FieldConfiguration::_internal_path_param_name() const {
  return _impl_.path_param_name_.Get();
}
inline void JSONSchema_FieldConfiguration::_internal_set_path_param_name(const std::string& value) {
  ;


  _impl_.path_param_name_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONSchema_FieldConfiguration::_internal_mutable_path_param_name() {
  ;
  return _impl_.path_param_name_.Mutable( GetArenaForAllocation());
}
inline std::string* JSONSchema_FieldConfiguration::release_path_param_name() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration.path_param_name)
  return _impl_.path_param_name_.Release();
}
inline void JSONSchema_FieldConfiguration::set_allocated_path_param_name(std::string* value) {
  _impl_.path_param_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_param_name_.IsDefault()) {
          _impl_.path_param_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration.path_param_name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// JSONSchema

// string ref = 3;
inline void JSONSchema::clear_ref() {
  _impl_.ref_.ClearToEmpty();
}
inline const std::string& JSONSchema::ref() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.ref)
  return _internal_ref();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JSONSchema::set_ref(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ref_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.ref)
}
inline std::string* JSONSchema::mutable_ref() {
  std::string* _s = _internal_mutable_ref();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.ref)
  return _s;
}
inline const std::string& JSONSchema::_internal_ref() const {
  return _impl_.ref_.Get();
}
inline void JSONSchema::_internal_set_ref(const std::string& value) {
  ;


  _impl_.ref_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONSchema::_internal_mutable_ref() {
  ;
  return _impl_.ref_.Mutable( GetArenaForAllocation());
}
inline std::string* JSONSchema::release_ref() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.ref)
  return _impl_.ref_.Release();
}
inline void JSONSchema::set_allocated_ref(std::string* value) {
  _impl_.ref_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ref_.IsDefault()) {
          _impl_.ref_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.ref)
}

// string title = 5;
inline void JSONSchema::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& JSONSchema::title() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JSONSchema::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.title)
}
inline std::string* JSONSchema::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.title)
  return _s;
}
inline const std::string& JSONSchema::_internal_title() const {
  return _impl_.title_.Get();
}
inline void JSONSchema::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONSchema::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* JSONSchema::release_title() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.title)
  return _impl_.title_.Release();
}
inline void JSONSchema::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.title)
}

// string description = 6;
inline void JSONSchema::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& JSONSchema::description() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JSONSchema::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.description)
}
inline std::string* JSONSchema::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.description)
  return _s;
}
inline const std::string& JSONSchema::_internal_description() const {
  return _impl_.description_.Get();
}
inline void JSONSchema::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONSchema::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* JSONSchema::release_description() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.description)
  return _impl_.description_.Release();
}
inline void JSONSchema::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.description)
}

// string default = 7;
inline void JSONSchema::clear_default_() {
  _impl_.default__.ClearToEmpty();
}
inline const std::string& JSONSchema::default_() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.default)
  return _internal_default_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JSONSchema::set_default_(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.default__.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.default)
}
inline std::string* JSONSchema::mutable_default_() {
  std::string* _s = _internal_mutable_default_();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.default)
  return _s;
}
inline const std::string& JSONSchema::_internal_default_() const {
  return _impl_.default__.Get();
}
inline void JSONSchema::_internal_set_default_(const std::string& value) {
  ;


  _impl_.default__.Set(value, GetArenaForAllocation());
}
inline std::string* JSONSchema::_internal_mutable_default_() {
  ;
  return _impl_.default__.Mutable( GetArenaForAllocation());
}
inline std::string* JSONSchema::release_default_() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.default)
  return _impl_.default__.Release();
}
inline void JSONSchema::set_allocated_default_(std::string* value) {
  _impl_.default__.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default__.IsDefault()) {
          _impl_.default__.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.default)
}

// bool read_only = 8;
inline void JSONSchema::clear_read_only() {
  _impl_.read_only_ = false;
}
inline bool JSONSchema::read_only() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.read_only)
  return _internal_read_only();
}
inline void JSONSchema::set_read_only(bool value) {
  _internal_set_read_only(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.read_only)
}
inline bool JSONSchema::_internal_read_only() const {
  return _impl_.read_only_;
}
inline void JSONSchema::_internal_set_read_only(bool value) {
  ;
  _impl_.read_only_ = value;
}

// string example = 9;
inline void JSONSchema::clear_example() {
  _impl_.example_.ClearToEmpty();
}
inline const std::string& JSONSchema::example() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.example)
  return _internal_example();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JSONSchema::set_example(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.example_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.example)
}
inline std::string* JSONSchema::mutable_example() {
  std::string* _s = _internal_mutable_example();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.example)
  return _s;
}
inline const std::string& JSONSchema::_internal_example() const {
  return _impl_.example_.Get();
}
inline void JSONSchema::_internal_set_example(const std::string& value) {
  ;


  _impl_.example_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONSchema::_internal_mutable_example() {
  ;
  return _impl_.example_.Mutable( GetArenaForAllocation());
}
inline std::string* JSONSchema::release_example() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.example)
  return _impl_.example_.Release();
}
inline void JSONSchema::set_allocated_example(std::string* value) {
  _impl_.example_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.example_.IsDefault()) {
          _impl_.example_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.example)
}

// double multiple_of = 10;
inline void JSONSchema::clear_multiple_of() {
  _impl_.multiple_of_ = 0;
}
inline double JSONSchema::multiple_of() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.multiple_of)
  return _internal_multiple_of();
}
inline void JSONSchema::set_multiple_of(double value) {
  _internal_set_multiple_of(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.multiple_of)
}
inline double JSONSchema::_internal_multiple_of() const {
  return _impl_.multiple_of_;
}
inline void JSONSchema::_internal_set_multiple_of(double value) {
  ;
  _impl_.multiple_of_ = value;
}

// double maximum = 11;
inline void JSONSchema::clear_maximum() {
  _impl_.maximum_ = 0;
}
inline double JSONSchema::maximum() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.maximum)
  return _internal_maximum();
}
inline void JSONSchema::set_maximum(double value) {
  _internal_set_maximum(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.maximum)
}
inline double JSONSchema::_internal_maximum() const {
  return _impl_.maximum_;
}
inline void JSONSchema::_internal_set_maximum(double value) {
  ;
  _impl_.maximum_ = value;
}

// bool exclusive_maximum = 12;
inline void JSONSchema::clear_exclusive_maximum() {
  _impl_.exclusive_maximum_ = false;
}
inline bool JSONSchema::exclusive_maximum() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.exclusive_maximum)
  return _internal_exclusive_maximum();
}
inline void JSONSchema::set_exclusive_maximum(bool value) {
  _internal_set_exclusive_maximum(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.exclusive_maximum)
}
inline bool JSONSchema::_internal_exclusive_maximum() const {
  return _impl_.exclusive_maximum_;
}
inline void JSONSchema::_internal_set_exclusive_maximum(bool value) {
  ;
  _impl_.exclusive_maximum_ = value;
}

// double minimum = 13;
inline void JSONSchema::clear_minimum() {
  _impl_.minimum_ = 0;
}
inline double JSONSchema::minimum() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.minimum)
  return _internal_minimum();
}
inline void JSONSchema::set_minimum(double value) {
  _internal_set_minimum(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.minimum)
}
inline double JSONSchema::_internal_minimum() const {
  return _impl_.minimum_;
}
inline void JSONSchema::_internal_set_minimum(double value) {
  ;
  _impl_.minimum_ = value;
}

// bool exclusive_minimum = 14;
inline void JSONSchema::clear_exclusive_minimum() {
  _impl_.exclusive_minimum_ = false;
}
inline bool JSONSchema::exclusive_minimum() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.exclusive_minimum)
  return _internal_exclusive_minimum();
}
inline void JSONSchema::set_exclusive_minimum(bool value) {
  _internal_set_exclusive_minimum(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.exclusive_minimum)
}
inline bool JSONSchema::_internal_exclusive_minimum() const {
  return _impl_.exclusive_minimum_;
}
inline void JSONSchema::_internal_set_exclusive_minimum(bool value) {
  ;
  _impl_.exclusive_minimum_ = value;
}

// uint64 max_length = 15;
inline void JSONSchema::clear_max_length() {
  _impl_.max_length_ = ::uint64_t{0u};
}
inline ::uint64_t JSONSchema::max_length() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.max_length)
  return _internal_max_length();
}
inline void JSONSchema::set_max_length(::uint64_t value) {
  _internal_set_max_length(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.max_length)
}
inline ::uint64_t JSONSchema::_internal_max_length() const {
  return _impl_.max_length_;
}
inline void JSONSchema::_internal_set_max_length(::uint64_t value) {
  ;
  _impl_.max_length_ = value;
}

// uint64 min_length = 16;
inline void JSONSchema::clear_min_length() {
  _impl_.min_length_ = ::uint64_t{0u};
}
inline ::uint64_t JSONSchema::min_length() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.min_length)
  return _internal_min_length();
}
inline void JSONSchema::set_min_length(::uint64_t value) {
  _internal_set_min_length(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.min_length)
}
inline ::uint64_t JSONSchema::_internal_min_length() const {
  return _impl_.min_length_;
}
inline void JSONSchema::_internal_set_min_length(::uint64_t value) {
  ;
  _impl_.min_length_ = value;
}

// string pattern = 17;
inline void JSONSchema::clear_pattern() {
  _impl_.pattern_.ClearToEmpty();
}
inline const std::string& JSONSchema::pattern() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.pattern)
  return _internal_pattern();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JSONSchema::set_pattern(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.pattern)
}
inline std::string* JSONSchema::mutable_pattern() {
  std::string* _s = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.pattern)
  return _s;
}
inline const std::string& JSONSchema::_internal_pattern() const {
  return _impl_.pattern_.Get();
}
inline void JSONSchema::_internal_set_pattern(const std::string& value) {
  ;


  _impl_.pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONSchema::_internal_mutable_pattern() {
  ;
  return _impl_.pattern_.Mutable( GetArenaForAllocation());
}
inline std::string* JSONSchema::release_pattern() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.pattern)
  return _impl_.pattern_.Release();
}
inline void JSONSchema::set_allocated_pattern(std::string* value) {
  _impl_.pattern_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pattern_.IsDefault()) {
          _impl_.pattern_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.pattern)
}

// uint64 max_items = 20;
inline void JSONSchema::clear_max_items() {
  _impl_.max_items_ = ::uint64_t{0u};
}
inline ::uint64_t JSONSchema::max_items() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.max_items)
  return _internal_max_items();
}
inline void JSONSchema::set_max_items(::uint64_t value) {
  _internal_set_max_items(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.max_items)
}
inline ::uint64_t JSONSchema::_internal_max_items() const {
  return _impl_.max_items_;
}
inline void JSONSchema::_internal_set_max_items(::uint64_t value) {
  ;
  _impl_.max_items_ = value;
}

// uint64 min_items = 21;
inline void JSONSchema::clear_min_items() {
  _impl_.min_items_ = ::uint64_t{0u};
}
inline ::uint64_t JSONSchema::min_items() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.min_items)
  return _internal_min_items();
}
inline void JSONSchema::set_min_items(::uint64_t value) {
  _internal_set_min_items(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.min_items)
}
inline ::uint64_t JSONSchema::_internal_min_items() const {
  return _impl_.min_items_;
}
inline void JSONSchema::_internal_set_min_items(::uint64_t value) {
  ;
  _impl_.min_items_ = value;
}

// bool unique_items = 22;
inline void JSONSchema::clear_unique_items() {
  _impl_.unique_items_ = false;
}
inline bool JSONSchema::unique_items() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.unique_items)
  return _internal_unique_items();
}
inline void JSONSchema::set_unique_items(bool value) {
  _internal_set_unique_items(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.unique_items)
}
inline bool JSONSchema::_internal_unique_items() const {
  return _impl_.unique_items_;
}
inline void JSONSchema::_internal_set_unique_items(bool value) {
  ;
  _impl_.unique_items_ = value;
}

// uint64 max_properties = 24;
inline void JSONSchema::clear_max_properties() {
  _impl_.max_properties_ = ::uint64_t{0u};
}
inline ::uint64_t JSONSchema::max_properties() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.max_properties)
  return _internal_max_properties();
}
inline void JSONSchema::set_max_properties(::uint64_t value) {
  _internal_set_max_properties(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.max_properties)
}
inline ::uint64_t JSONSchema::_internal_max_properties() const {
  return _impl_.max_properties_;
}
inline void JSONSchema::_internal_set_max_properties(::uint64_t value) {
  ;
  _impl_.max_properties_ = value;
}

// uint64 min_properties = 25;
inline void JSONSchema::clear_min_properties() {
  _impl_.min_properties_ = ::uint64_t{0u};
}
inline ::uint64_t JSONSchema::min_properties() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.min_properties)
  return _internal_min_properties();
}
inline void JSONSchema::set_min_properties(::uint64_t value) {
  _internal_set_min_properties(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.min_properties)
}
inline ::uint64_t JSONSchema::_internal_min_properties() const {
  return _impl_.min_properties_;
}
inline void JSONSchema::_internal_set_min_properties(::uint64_t value) {
  ;
  _impl_.min_properties_ = value;
}

// repeated string required = 26;
inline int JSONSchema::_internal_required_size() const {
  return _impl_.required_.size();
}
inline int JSONSchema::required_size() const {
  return _internal_required_size();
}
inline void JSONSchema::clear_required() {
  _internal_mutable_required()->Clear();
}
inline std::string* JSONSchema::add_required() {
  std::string* _s = _internal_add_required();
  // @@protoc_insertion_point(field_add_mutable:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.required)
  return _s;
}
inline const std::string& JSONSchema::required(int index) const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.required)
  return _internal_required(index);
}
inline std::string* JSONSchema::mutable_required(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.required)
  return _internal_mutable_required()->Mutable(index);
}
inline void JSONSchema::set_required(int index, const std::string& value) {
  _internal_mutable_required()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.required)
}
inline void JSONSchema::set_required(int index, std::string&& value) {
  _internal_mutable_required()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.required)
}
inline void JSONSchema::set_required(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_required()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.required)
}
inline void JSONSchema::set_required(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_required()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.required)
}
inline void JSONSchema::set_required(int index, absl::string_view value) {
  _internal_mutable_required()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.required)
}
inline void JSONSchema::add_required(const std::string& value) {
  _internal_mutable_required()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.required)
}
inline void JSONSchema::add_required(std::string&& value) {
  _internal_mutable_required()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.required)
}
inline void JSONSchema::add_required(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_required()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.required)
}
inline void JSONSchema::add_required(const char* value, std::size_t size) {
  _internal_mutable_required()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.required)
}
inline void JSONSchema::add_required(absl::string_view value) {
  _internal_mutable_required()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.required)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JSONSchema::required() const {
  // @@protoc_insertion_point(field_list:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.required)
  return _internal_required();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* JSONSchema::mutable_required() {
  // @@protoc_insertion_point(field_mutable_list:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.required)
  return _internal_mutable_required();
}
inline const std::string& JSONSchema::_internal_required(int index) const {
  return _internal_required().Get(index);
}
inline std::string* JSONSchema::_internal_add_required() {
  return _internal_mutable_required()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JSONSchema::_internal_required() const {
  return _impl_.required_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
JSONSchema::_internal_mutable_required() {
  return &_impl_.required_;
}

// repeated string array = 34;
inline int JSONSchema::_internal_array_size() const {
  return _impl_.array_.size();
}
inline int JSONSchema::array_size() const {
  return _internal_array_size();
}
inline void JSONSchema::clear_array() {
  _internal_mutable_array()->Clear();
}
inline std::string* JSONSchema::add_array() {
  std::string* _s = _internal_add_array();
  // @@protoc_insertion_point(field_add_mutable:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.array)
  return _s;
}
inline const std::string& JSONSchema::array(int index) const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.array)
  return _internal_array(index);
}
inline std::string* JSONSchema::mutable_array(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.array)
  return _internal_mutable_array()->Mutable(index);
}
inline void JSONSchema::set_array(int index, const std::string& value) {
  _internal_mutable_array()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.array)
}
inline void JSONSchema::set_array(int index, std::string&& value) {
  _internal_mutable_array()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.array)
}
inline void JSONSchema::set_array(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_array()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.array)
}
inline void JSONSchema::set_array(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_array()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.array)
}
inline void JSONSchema::set_array(int index, absl::string_view value) {
  _internal_mutable_array()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.array)
}
inline void JSONSchema::add_array(const std::string& value) {
  _internal_mutable_array()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.array)
}
inline void JSONSchema::add_array(std::string&& value) {
  _internal_mutable_array()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.array)
}
inline void JSONSchema::add_array(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_array()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.array)
}
inline void JSONSchema::add_array(const char* value, std::size_t size) {
  _internal_mutable_array()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.array)
}
inline void JSONSchema::add_array(absl::string_view value) {
  _internal_mutable_array()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.array)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JSONSchema::array() const {
  // @@protoc_insertion_point(field_list:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.array)
  return _internal_array();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* JSONSchema::mutable_array() {
  // @@protoc_insertion_point(field_mutable_list:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.array)
  return _internal_mutable_array();
}
inline const std::string& JSONSchema::_internal_array(int index) const {
  return _internal_array().Get(index);
}
inline std::string* JSONSchema::_internal_add_array() {
  return _internal_mutable_array()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JSONSchema::_internal_array() const {
  return _impl_.array_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
JSONSchema::_internal_mutable_array() {
  return &_impl_.array_;
}

// repeated .grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.JSONSchemaSimpleTypes type = 35;
inline int JSONSchema::_internal_type_size() const {
  return _impl_.type_.size();
}
inline int JSONSchema::type_size() const {
  return _internal_type_size();
}
inline void JSONSchema::clear_type() {
  _internal_mutable_type()->Clear();
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_JSONSchemaSimpleTypes JSONSchema::type(int index) const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.type)
  return _internal_type(index);
}
inline void JSONSchema::set_type(int index, ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_JSONSchemaSimpleTypes value) {
  _internal_mutable_type()->Set(index, value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.type)
}
inline void JSONSchema::add_type(::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_JSONSchemaSimpleTypes value) {
  _internal_add_type(value);
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& JSONSchema::type() const {
  // @@protoc_insertion_point(field_list:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.type)
  return _internal_type();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* JSONSchema::mutable_type() {
  // @@protoc_insertion_point(field_mutable_list:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.type)
  return _internal_mutable_type();
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_JSONSchemaSimpleTypes JSONSchema::_internal_type(int index) const {
  return static_cast<::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_JSONSchemaSimpleTypes>(_internal_type().Get(index));
}
inline void JSONSchema::_internal_add_type(::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_JSONSchemaSimpleTypes value) {
  _internal_mutable_type()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& JSONSchema::_internal_type() const {
  return _impl_.type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* JSONSchema::_internal_mutable_type() {
  return &_impl_.type_;
}

// string format = 36;
inline void JSONSchema::clear_format() {
  _impl_.format_.ClearToEmpty();
}
inline const std::string& JSONSchema::format() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.format)
  return _internal_format();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JSONSchema::set_format(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.format_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.format)
}
inline std::string* JSONSchema::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.format)
  return _s;
}
inline const std::string& JSONSchema::_internal_format() const {
  return _impl_.format_.Get();
}
inline void JSONSchema::_internal_set_format(const std::string& value) {
  ;


  _impl_.format_.Set(value, GetArenaForAllocation());
}
inline std::string* JSONSchema::_internal_mutable_format() {
  ;
  return _impl_.format_.Mutable( GetArenaForAllocation());
}
inline std::string* JSONSchema::release_format() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.format)
  return _impl_.format_.Release();
}
inline void JSONSchema::set_allocated_format(std::string* value) {
  _impl_.format_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.format_.IsDefault()) {
          _impl_.format_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.format)
}

// repeated string enum = 46;
inline int JSONSchema::_internal_enum__size() const {
  return _impl_.enum__.size();
}
inline int JSONSchema::enum__size() const {
  return _internal_enum__size();
}
inline void JSONSchema::clear_enum_() {
  _internal_mutable_enum_()->Clear();
}
inline std::string* JSONSchema::add_enum_() {
  std::string* _s = _internal_add_enum_();
  // @@protoc_insertion_point(field_add_mutable:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.enum)
  return _s;
}
inline const std::string& JSONSchema::enum_(int index) const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.enum)
  return _internal_enum_(index);
}
inline std::string* JSONSchema::mutable_enum_(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.enum)
  return _internal_mutable_enum_()->Mutable(index);
}
inline void JSONSchema::set_enum_(int index, const std::string& value) {
  _internal_mutable_enum_()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.enum)
}
inline void JSONSchema::set_enum_(int index, std::string&& value) {
  _internal_mutable_enum_()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.enum)
}
inline void JSONSchema::set_enum_(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_enum_()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.enum)
}
inline void JSONSchema::set_enum_(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_enum_()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.enum)
}
inline void JSONSchema::set_enum_(int index, absl::string_view value) {
  _internal_mutable_enum_()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.enum)
}
inline void JSONSchema::add_enum_(const std::string& value) {
  _internal_mutable_enum_()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.enum)
}
inline void JSONSchema::add_enum_(std::string&& value) {
  _internal_mutable_enum_()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.enum)
}
inline void JSONSchema::add_enum_(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_enum_()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.enum)
}
inline void JSONSchema::add_enum_(const char* value, std::size_t size) {
  _internal_mutable_enum_()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.enum)
}
inline void JSONSchema::add_enum_(absl::string_view value) {
  _internal_mutable_enum_()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.enum)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JSONSchema::enum_() const {
  // @@protoc_insertion_point(field_list:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.enum)
  return _internal_enum_();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* JSONSchema::mutable_enum_() {
  // @@protoc_insertion_point(field_mutable_list:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.enum)
  return _internal_mutable_enum_();
}
inline const std::string& JSONSchema::_internal_enum_(int index) const {
  return _internal_enum_().Get(index);
}
inline std::string* JSONSchema::_internal_add_enum_() {
  return _internal_mutable_enum_()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JSONSchema::_internal_enum_() const {
  return _impl_.enum__;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
JSONSchema::_internal_mutable_enum_() {
  return &_impl_.enum__;
}

// .grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration field_configuration = 1001;
inline bool JSONSchema::has_field_configuration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.field_configuration_ != nullptr);
  return value;
}
inline void JSONSchema::clear_field_configuration() {
  if (_impl_.field_configuration_ != nullptr) _impl_.field_configuration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration& JSONSchema::_internal_field_configuration() const {
  const ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* p = _impl_.field_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration&>(
      ::grpc::gateway::protoc_gen_openapiv2::options::_JSONSchema_FieldConfiguration_default_instance_);
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration& JSONSchema::field_configuration() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.field_configuration)
  return _internal_field_configuration();
}
inline void JSONSchema::unsafe_arena_set_allocated_field_configuration(
    ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* field_configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.field_configuration_);
  }
  _impl_.field_configuration_ = field_configuration;
  if (field_configuration) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.field_configuration)
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* JSONSchema::release_field_configuration() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* temp = _impl_.field_configuration_;
  _impl_.field_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* JSONSchema::unsafe_arena_release_field_configuration() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.field_configuration)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* temp = _impl_.field_configuration_;
  _impl_.field_configuration_ = nullptr;
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* JSONSchema::_internal_mutable_field_configuration() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.field_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration>(GetArenaForAllocation());
    _impl_.field_configuration_ = p;
  }
  return _impl_.field_configuration_;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* JSONSchema::mutable_field_configuration() {
  ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* _msg = _internal_mutable_field_configuration();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.field_configuration)
  return _msg;
}
inline void JSONSchema::set_allocated_field_configuration(::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_FieldConfiguration* field_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.field_configuration_;
  }
  if (field_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(field_configuration);
    if (message_arena != submessage_arena) {
      field_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field_configuration, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.field_configuration_ = field_configuration;
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.field_configuration)
}

// map<string, .google.protobuf.Value> extensions = 48;
inline int JSONSchema::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int JSONSchema::extensions_size() const {
  return _internal_extensions_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
JSONSchema::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
JSONSchema::extensions() const {
  // @@protoc_insertion_point(field_map:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
JSONSchema::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
JSONSchema::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.extensions)
  return _internal_mutable_extensions();
}

// -------------------------------------------------------------------

// Tag

// string description = 2;
inline void Tag::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Tag::description() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Tag.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Tag::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.Tag.description)
}
inline std::string* Tag::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Tag.description)
  return _s;
}
inline const std::string& Tag::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Tag::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Tag::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* Tag::release_description() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Tag.description)
  return _impl_.description_.Release();
}
inline void Tag::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Tag.description)
}

// .grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation external_docs = 3;
inline bool Tag::has_external_docs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.external_docs_ != nullptr);
  return value;
}
inline void Tag::clear_external_docs() {
  if (_impl_.external_docs_ != nullptr) _impl_.external_docs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& Tag::_internal_external_docs() const {
  const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* p = _impl_.external_docs_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation&>(
      ::grpc::gateway::protoc_gen_openapiv2::options::_ExternalDocumentation_default_instance_);
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation& Tag::external_docs() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.Tag.external_docs)
  return _internal_external_docs();
}
inline void Tag::unsafe_arena_set_allocated_external_docs(
    ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.external_docs_);
  }
  _impl_.external_docs_ = external_docs;
  if (external_docs) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Tag.external_docs)
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Tag::release_external_docs() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Tag::unsafe_arena_release_external_docs() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.Tag.external_docs)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* temp = _impl_.external_docs_;
  _impl_.external_docs_ = nullptr;
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Tag::_internal_mutable_external_docs() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.external_docs_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation>(GetArenaForAllocation());
    _impl_.external_docs_ = p;
  }
  return _impl_.external_docs_;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* Tag::mutable_external_docs() {
  ::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* _msg = _internal_mutable_external_docs();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.Tag.external_docs)
  return _msg;
}
inline void Tag::set_allocated_external_docs(::grpc::gateway::protoc_gen_openapiv2::options::ExternalDocumentation* external_docs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.external_docs_;
  }
  if (external_docs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_docs);
    if (message_arena != submessage_arena) {
      external_docs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_docs, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.external_docs_ = external_docs;
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.Tag.external_docs)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SecurityDefinitions

// map<string, .grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme> security = 1;
inline int SecurityDefinitions::_internal_security_size() const {
  return _impl_.security_.size();
}
inline int SecurityDefinitions::security_size() const {
  return _internal_security_size();
}
inline void SecurityDefinitions::clear_security() {
  _impl_.security_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme >&
SecurityDefinitions::_internal_security() const {
  return _impl_.security_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme >&
SecurityDefinitions::security() const {
  // @@protoc_insertion_point(field_map:grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.security)
  return _internal_security();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme >*
SecurityDefinitions::_internal_mutable_security() {
  return _impl_.security_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme >*
SecurityDefinitions::mutable_security() {
  // @@protoc_insertion_point(field_mutable_map:grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.security)
  return _internal_mutable_security();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SecurityScheme

// .grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Type type = 1;
inline void SecurityScheme::clear_type() {
  _impl_.type_ = 0;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Type SecurityScheme::type() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.type)
  return _internal_type();
}
inline void SecurityScheme::set_type(::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Type value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.type)
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Type SecurityScheme::_internal_type() const {
  return static_cast<::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Type>(_impl_.type_);
}
inline void SecurityScheme::_internal_set_type(::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Type value) {
  ;
  _impl_.type_ = value;
}

// string description = 2;
inline void SecurityScheme::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& SecurityScheme::description() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SecurityScheme::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.description)
}
inline std::string* SecurityScheme::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.description)
  return _s;
}
inline const std::string& SecurityScheme::_internal_description() const {
  return _impl_.description_.Get();
}
inline void SecurityScheme::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityScheme::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* SecurityScheme::release_description() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.description)
  return _impl_.description_.Release();
}
inline void SecurityScheme::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.description)
}

// string name = 3;
inline void SecurityScheme::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SecurityScheme::name() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SecurityScheme::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.name)
}
inline std::string* SecurityScheme::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.name)
  return _s;
}
inline const std::string& SecurityScheme::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SecurityScheme::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityScheme::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* SecurityScheme::release_name() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.name)
  return _impl_.name_.Release();
}
inline void SecurityScheme::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.name)
}

// .grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.In in = 4;
inline void SecurityScheme::clear_in() {
  _impl_.in_ = 0;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_In SecurityScheme::in() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.in)
  return _internal_in();
}
inline void SecurityScheme::set_in(::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_In value) {
   _internal_set_in(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.in)
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_In SecurityScheme::_internal_in() const {
  return static_cast<::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_In>(_impl_.in_);
}
inline void SecurityScheme::_internal_set_in(::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_In value) {
  ;
  _impl_.in_ = value;
}

// .grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Flow flow = 5;
inline void SecurityScheme::clear_flow() {
  _impl_.flow_ = 0;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Flow SecurityScheme::flow() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.flow)
  return _internal_flow();
}
inline void SecurityScheme::set_flow(::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Flow value) {
   _internal_set_flow(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.flow)
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Flow SecurityScheme::_internal_flow() const {
  return static_cast<::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Flow>(_impl_.flow_);
}
inline void SecurityScheme::_internal_set_flow(::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Flow value) {
  ;
  _impl_.flow_ = value;
}

// string authorization_url = 6;
inline void SecurityScheme::clear_authorization_url() {
  _impl_.authorization_url_.ClearToEmpty();
}
inline const std::string& SecurityScheme::authorization_url() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.authorization_url)
  return _internal_authorization_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SecurityScheme::set_authorization_url(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.authorization_url_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.authorization_url)
}
inline std::string* SecurityScheme::mutable_authorization_url() {
  std::string* _s = _internal_mutable_authorization_url();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.authorization_url)
  return _s;
}
inline const std::string& SecurityScheme::_internal_authorization_url() const {
  return _impl_.authorization_url_.Get();
}
inline void SecurityScheme::_internal_set_authorization_url(const std::string& value) {
  ;


  _impl_.authorization_url_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityScheme::_internal_mutable_authorization_url() {
  ;
  return _impl_.authorization_url_.Mutable( GetArenaForAllocation());
}
inline std::string* SecurityScheme::release_authorization_url() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.authorization_url)
  return _impl_.authorization_url_.Release();
}
inline void SecurityScheme::set_allocated_authorization_url(std::string* value) {
  _impl_.authorization_url_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.authorization_url_.IsDefault()) {
          _impl_.authorization_url_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.authorization_url)
}

// string token_url = 7;
inline void SecurityScheme::clear_token_url() {
  _impl_.token_url_.ClearToEmpty();
}
inline const std::string& SecurityScheme::token_url() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.token_url)
  return _internal_token_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SecurityScheme::set_token_url(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.token_url_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.token_url)
}
inline std::string* SecurityScheme::mutable_token_url() {
  std::string* _s = _internal_mutable_token_url();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.token_url)
  return _s;
}
inline const std::string& SecurityScheme::_internal_token_url() const {
  return _impl_.token_url_.Get();
}
inline void SecurityScheme::_internal_set_token_url(const std::string& value) {
  ;


  _impl_.token_url_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityScheme::_internal_mutable_token_url() {
  ;
  return _impl_.token_url_.Mutable( GetArenaForAllocation());
}
inline std::string* SecurityScheme::release_token_url() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.token_url)
  return _impl_.token_url_.Release();
}
inline void SecurityScheme::set_allocated_token_url(std::string* value) {
  _impl_.token_url_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.token_url_.IsDefault()) {
          _impl_.token_url_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.token_url)
}

// .grpc.gateway.protoc_gen_openapiv2.options.Scopes scopes = 8;
inline bool SecurityScheme::has_scopes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scopes_ != nullptr);
  return value;
}
inline void SecurityScheme::clear_scopes() {
  if (_impl_.scopes_ != nullptr) _impl_.scopes_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::Scopes& SecurityScheme::_internal_scopes() const {
  const ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* p = _impl_.scopes_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc::gateway::protoc_gen_openapiv2::options::Scopes&>(
      ::grpc::gateway::protoc_gen_openapiv2::options::_Scopes_default_instance_);
}
inline const ::grpc::gateway::protoc_gen_openapiv2::options::Scopes& SecurityScheme::scopes() const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.scopes)
  return _internal_scopes();
}
inline void SecurityScheme::unsafe_arena_set_allocated_scopes(
    ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* scopes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scopes_);
  }
  _impl_.scopes_ = scopes;
  if (scopes) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.scopes)
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* SecurityScheme::release_scopes() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* temp = _impl_.scopes_;
  _impl_.scopes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* SecurityScheme::unsafe_arena_release_scopes() {
  // @@protoc_insertion_point(field_release:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.scopes)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* temp = _impl_.scopes_;
  _impl_.scopes_ = nullptr;
  return temp;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* SecurityScheme::_internal_mutable_scopes() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.scopes_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc::gateway::protoc_gen_openapiv2::options::Scopes>(GetArenaForAllocation());
    _impl_.scopes_ = p;
  }
  return _impl_.scopes_;
}
inline ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* SecurityScheme::mutable_scopes() {
  ::grpc::gateway::protoc_gen_openapiv2::options::Scopes* _msg = _internal_mutable_scopes();
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.scopes)
  return _msg;
}
inline void SecurityScheme::set_allocated_scopes(::grpc::gateway::protoc_gen_openapiv2::options::Scopes* scopes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.scopes_;
  }
  if (scopes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scopes);
    if (message_arena != submessage_arena) {
      scopes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scopes, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.scopes_ = scopes;
  // @@protoc_insertion_point(field_set_allocated:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.scopes)
}

// map<string, .google.protobuf.Value> extensions = 9;
inline int SecurityScheme::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int SecurityScheme::extensions_size() const {
  return _internal_extensions_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
SecurityScheme::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >&
SecurityScheme::extensions() const {
  // @@protoc_insertion_point(field_map:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
SecurityScheme::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Value >*
SecurityScheme::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.extensions)
  return _internal_mutable_extensions();
}

// -------------------------------------------------------------------

// SecurityRequirement_SecurityRequirementValue

// repeated string scope = 1;
inline int SecurityRequirement_SecurityRequirementValue::_internal_scope_size() const {
  return _impl_.scope_.size();
}
inline int SecurityRequirement_SecurityRequirementValue::scope_size() const {
  return _internal_scope_size();
}
inline void SecurityRequirement_SecurityRequirementValue::clear_scope() {
  _internal_mutable_scope()->Clear();
}
inline std::string* SecurityRequirement_SecurityRequirementValue::add_scope() {
  std::string* _s = _internal_add_scope();
  // @@protoc_insertion_point(field_add_mutable:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue.scope)
  return _s;
}
inline const std::string& SecurityRequirement_SecurityRequirementValue::scope(int index) const {
  // @@protoc_insertion_point(field_get:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue.scope)
  return _internal_scope(index);
}
inline std::string* SecurityRequirement_SecurityRequirementValue::mutable_scope(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue.scope)
  return _internal_mutable_scope()->Mutable(index);
}
inline void SecurityRequirement_SecurityRequirementValue::set_scope(int index, const std::string& value) {
  _internal_mutable_scope()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue.scope)
}
inline void SecurityRequirement_SecurityRequirementValue::set_scope(int index, std::string&& value) {
  _internal_mutable_scope()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue.scope)
}
inline void SecurityRequirement_SecurityRequirementValue::set_scope(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_scope()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue.scope)
}
inline void SecurityRequirement_SecurityRequirementValue::set_scope(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_scope()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue.scope)
}
inline void SecurityRequirement_SecurityRequirementValue::set_scope(int index, absl::string_view value) {
  _internal_mutable_scope()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue.scope)
}
inline void SecurityRequirement_SecurityRequirementValue::add_scope(const std::string& value) {
  _internal_mutable_scope()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue.scope)
}
inline void SecurityRequirement_SecurityRequirementValue::add_scope(std::string&& value) {
  _internal_mutable_scope()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue.scope)
}
inline void SecurityRequirement_SecurityRequirementValue::add_scope(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_scope()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue.scope)
}
inline void SecurityRequirement_SecurityRequirementValue::add_scope(const char* value, std::size_t size) {
  _internal_mutable_scope()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue.scope)
}
inline void SecurityRequirement_SecurityRequirementValue::add_scope(absl::string_view value) {
  _internal_mutable_scope()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue.scope)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SecurityRequirement_SecurityRequirementValue::scope() const {
  // @@protoc_insertion_point(field_list:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue.scope)
  return _internal_scope();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* SecurityRequirement_SecurityRequirementValue::mutable_scope() {
  // @@protoc_insertion_point(field_mutable_list:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue.scope)
  return _internal_mutable_scope();
}
inline const std::string& SecurityRequirement_SecurityRequirementValue::_internal_scope(int index) const {
  return _internal_scope().Get(index);
}
inline std::string* SecurityRequirement_SecurityRequirementValue::_internal_add_scope() {
  return _internal_mutable_scope()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SecurityRequirement_SecurityRequirementValue::_internal_scope() const {
  return _impl_.scope_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SecurityRequirement_SecurityRequirementValue::_internal_mutable_scope() {
  return &_impl_.scope_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SecurityRequirement

// map<string, .grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue> security_requirement = 1;
inline int SecurityRequirement::_internal_security_requirement_size() const {
  return _impl_.security_requirement_.size();
}
inline int SecurityRequirement::security_requirement_size() const {
  return _internal_security_requirement_size();
}
inline void SecurityRequirement::clear_security_requirement() {
  _impl_.security_requirement_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement_SecurityRequirementValue >&
SecurityRequirement::_internal_security_requirement() const {
  return _impl_.security_requirement_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement_SecurityRequirementValue >&
SecurityRequirement::security_requirement() const {
  // @@protoc_insertion_point(field_map:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.security_requirement)
  return _internal_security_requirement();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement_SecurityRequirementValue >*
SecurityRequirement::_internal_mutable_security_requirement() {
  return _impl_.security_requirement_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::grpc::gateway::protoc_gen_openapiv2::options::SecurityRequirement_SecurityRequirementValue >*
SecurityRequirement::mutable_security_requirement() {
  // @@protoc_insertion_point(field_mutable_map:grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.security_requirement)
  return _internal_mutable_security_requirement();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Scopes

// map<string, string> scope = 1;
inline int Scopes::_internal_scope_size() const {
  return _impl_.scope_.size();
}
inline int Scopes::scope_size() const {
  return _internal_scope_size();
}
inline void Scopes::clear_scope() {
  _impl_.scope_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Scopes::_internal_scope() const {
  return _impl_.scope_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Scopes::scope() const {
  // @@protoc_insertion_point(field_map:grpc.gateway.protoc_gen_openapiv2.options.Scopes.scope)
  return _internal_scope();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Scopes::_internal_mutable_scope() {
  return _impl_.scope_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Scopes::mutable_scope() {
  // @@protoc_insertion_point(field_mutable_map:grpc.gateway.protoc_gen_openapiv2.options.Scopes.scope)
  return _internal_mutable_scope();
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace options
}  // namespace protoc_gen_openapiv2
}  // namespace gateway
}  // namespace grpc


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_JSONSchemaSimpleTypes> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_JSONSchemaSimpleTypes>() {
  return ::grpc::gateway::protoc_gen_openapiv2::options::JSONSchema_JSONSchemaSimpleTypes_descriptor();
}
template <>
struct is_proto_enum<::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Type>() {
  return ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Type_descriptor();
}
template <>
struct is_proto_enum<::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_In> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_In>() {
  return ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_In_descriptor();
}
template <>
struct is_proto_enum<::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Flow> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Flow>() {
  return ::grpc::gateway::protoc_gen_openapiv2::options::SecurityScheme_Flow_descriptor();
}
template <>
struct is_proto_enum<::grpc::gateway::protoc_gen_openapiv2::options::Scheme> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::grpc::gateway::protoc_gen_openapiv2::options::Scheme>() {
  return ::grpc::gateway::protoc_gen_openapiv2::options::Scheme_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_protoc_2dgen_2dopenapiv2_2foptions_2fopenapiv2_2eproto_2epb_2eh
